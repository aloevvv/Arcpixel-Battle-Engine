<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GAME NAME HERE</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>   
    body {
      background: #333;
      color: white;
      font-family: "Press Start 2P", sans-serif;
      text-align: center;
      margin: 0;
    }
    canvas {
      background: #737373;
      display: block;
      margin: 2em auto;
      border: 2px solid white;
    }
    #game-hud {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #002591;
      color: white;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 10px;
      box-sizing: border-box;
      border-top: 2px solid black;
    }
    .hud-section {
      text-align: center;
      padding: 0 1em;
    }
    #player-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #hp-bar-container {
      width: 150px;
      height: 20px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
    }
    #hp-bar {
      width: 100%;
      height: 100%;
      background-color: #00FF00;
      transition: width 0.5s linear;
    }
    #hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.8em;
      text-shadow: 1px 1px 2px black;
    }
    #battle-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      display: none;
      z-index: 2000;
    }
    #enemy-display {
      background-color: #555;
      padding: 20px;
      border: 2px solid white;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    #enemy-display button {
      background-color: #333;
      color: white;
      border: 1px solid white;
      cursor: pointer;
      padding: 10px;
      font-family: "Press Start 2P", sans-serif;
      min-width: 100px;
      user-select: none;
    }
    #enemy-display button.selected {
      border: 2px solid red;
      background-color: #555;
    }
    #battle-controls button {
      font-family: "Press Start 2P", sans-serif;
      padding: 10px 20px;
      cursor: pointer;
      margin: 5px;
    }
    #player-battle-status {
      background-color: #002591;
      color: white;
      border: 2px solid black;
      padding: 10px;
      margin-top: 20px;
      width: 250px;
      text-align: left;
    }
    #player-battle-status p {
      margin: 0;
      font-size: 1em;
      user-select: none;
    }
    #player-battle-status .hp-bar-container {
      width: 100%;
      height: 15px;
      background-color: #555;
      border: 1px solid white;
      position: relative;
      margin: 8px 0;
    }
    #player-battle-status .hp-bar {
      height: 100%;
      background-color: #00FF00;
    }
    .damage-number {
  position: fixed;
  color: #ffffff;
  font-family: "Press Start 2P", sans-serif;
  font-size: 1.2em;
  pointer-events: none;
  z-index: 10000;
  text-shadow: 2px 2px 0px #000;
  animation: damageFloat 1s forwards ease-out;
}

@keyframes damageFloat {
  0% { transform: translate(-50%, 0); opacity: 1; }
  100% { transform: translate(-50%, -60px); opacity: 0; }
}
    .spark {
  position: fixed;
  width: 6px;
  height: 6px;
  background: #ffff00;
  pointer-events: none;
  z-index: 10001;
  box-shadow: 0 0 6px 2px #ffa500;
  border-radius: 2px;
}

@keyframes sparkOut {
  0% { transform: translate(0, 0) scale(1); opacity: 1; }
  100% { transform: translate(var(--dx), var(--dy)) scale(0); opacity: 0; }
}
.sword-trail {
  position: fixed;
  width: 150px;
  height: 40px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
  transform: rotate(-30deg) skewX(-45deg);
  pointer-events: none;
  z-index: 10002;
  animation: swordSlash 0.4s ease-out forwards;
}

@keyframes swordSlash {
  0% { transform: translate(-100px, 0) rotate(-30deg) scaleX(0); opacity: 0; }
  50% { transform: translate(0, 0) rotate(-30deg) scaleX(1.5); opacity: 1; }
  100% { transform: translate(100px, 0) rotate(-30deg) scaleX(0); opacity: 0; }
}
.telegraph-mark {
  position: absolute;
  top: -40px;
  left: 50%;
  transform: translateX(-50%);
  color: #ff0000;
  font-size: 30px;
  font-weight: bold;
  text-shadow: 2px 2px black;
  animation: pulse 0.5s infinite;
}

@keyframes pulse {
  0% { transform: translateX(-50%) scale(1); }
  50% { transform: translateX(-50%) scale(1.3); }
  100% { transform: translateX(-50%) scale(1); }
}
  #tea-ui {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 480px;
  height: 400px;
  background: #001a33;
  border: 4px solid white;
  z-index: 5000;
  color: white;
  display: none;
  flex-direction: row;
  padding: 20px;
  gap: 20px;
}

#tea-slots {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.tea-slot {
  width: 150px;
  height: 40px;
  background: #002591;
  border: 2px solid white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}

#tea-inventory-list {
  flex-grow: 1;
  border-left: 2px solid white;
  padding-left: 10px;
  overflow-y: auto;
}

#tea-inventory-list div {
  background: #333;
  padding: 8px;
  margin-bottom: 5px;
  border: 2px solid #999;
  cursor: pointer;
}


#boil-ui {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 480px;
  height: 300px;
  background: #001a33;
  border: 4px solid white;
  z-index: 5000;
  color: white;
  display: none;
  flex-direction: column;
  padding: 20px;
}

#boil-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  flex-grow: 1;
}


#kettle {
  width:120px;
  height:80px;
  background:#333;
  border:3px solid #777;
  position:relative;
}

.steam {
  width:10px;
  height:10px;
  background:#666;
  position:absolute;
  animation:steamRise 1.2s infinite;
}

.s1 { left:20px; top:-10px; animation-delay:0s; }
.s2 { left:50px; top:-10px; animation-delay:0.3s; }
.s3 { left:80px; top:-10px; animation-delay:0.6s; }

@keyframes steamRise {
  0% { opacity:0; transform:translateY(0); }
  50% { opacity:1; transform:translateY(-10px); }
  100% { opacity:0; transform:translateY(-20px); }
}

#boil-bar {
  width:300px;
  height:20px;
  background:#222;
  border:2px solid #999;
  position:relative;
}

#green-zone {
  position:absolute;
  left:140px;
  width:20px;
  height:100%;
  background:#00ff00;
}

#red-progress {
  position:absolute;
  left:0;
  top:0;
  height:100%;
  width:0;
  background:#ff0000;
}

#boil-instructions {
  font-size:14px;
  opacity:0.8;
}
    .attack-bar-container {
  width: 100%;
  height: 9px;
  background-color: #400;
  border: 2px solid black;
  margin-top: 4px;
  position: relative;
  overflow: hidden;
}

.attack-bar-fill {
  width: 0%;
  height: 100%;
  background-color: #f00;
}
    #stats {
      position: relative;
      user-select: none;
    }
    .stats-popup {
      position: absolute;
      bottom: 100%;
      left: 0;
      width: 200px;
      background-color: #002591;
      border: 2px solid black;
      padding: 10px;
      color: white;
      text-align: left;
      z-index: 1000;
      font-size: 0.75em;
      line-height: 1.2em;
    }

.shaking {
  animation: shake 1.0s cubic-bezier(.36,.07,.19,.97) both;
  transform: translate3d(0, 0, 0);
}
@keyframes shake {
  10%, 90% { transform: translate3d(-2px, 0, 0); }
  20%, 80% { transform: translate3d(3px, 0, 0); }
  30%, 50%, 70% { transform: translate3d(-5px, 0, 0); }
  40%, 60% { transform: translate3d(5px, 0, 0); }
}

    #victory-banner {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 9999;
  font-family: "Press Start 2P", sans-serif;
  font-size: 3em;
  color: white;
  pointer-events: none;
  display: flex;
  gap: 10px;
}

.victory-letter {
  display: inline-block;
  animation: letterPulse 0.4s ease-out forwards;
}

@keyframes letterPulse {
  0% { transform: scale(1); color: white; }
  50% { transform: scale(1.5); color: #00ffff; text-shadow: 0 0 15px #00ffff; }
  100% { transform: scale(1.2); color: white; }
}
.fade-out {
  opacity: 0 !important;
  transition: opacity 0.7s ease-out !important;
}
@keyframes char-shake {
  0% { transform: translate(1px, 1px); }
  25% { transform: translate(-1px, -1px); }
  50% { transform: translate(-1px, 1px); }
  75% { transform: translate(1px, -1px); }
  100% { transform: translate(0, 0); }
}
@keyframes char-wave {
  from { transform: translateY(0); }
  to { transform: translateY(-5px); }
}
@keyframes char-glitch {
  0% { opacity: 1; transform: skew(0deg); }
  20% { opacity: 0.8; transform: skew(10deg); color: #ff00ff; }
  40% { opacity: 1; transform: skew(-10deg); color: #00ffff; }
  100% { opacity: 1; transform: skew(0deg); }
}

.dialog-char { display: inline-block; min-width: 0.2em; }
.effect-shake { animation: char-shake 0.15s infinite; }
.effect-wave { animation: char-wave 0.5s infinite alternate ease-in-out; }
.effect-glitch { animation: char-glitch 0.2s infinite; }
    
    .enemy-target.stunned {
  filter: grayscale(100%);
  opacity: 0.6;
}
    .enemy-target.shielded {
  box-shadow: 0 0 10px 10px rgba(0, 150, 255, 0.8);
  border-color: #0096ff;
}
    .enemy-target.poisoned {
  box-shadow: 0 0 10px 10px rgba(0, 120, 0, 0.8);
  border-color: #007800;
}
    .enemy-target.enraged {
  box-shadow: 0 0 10px 10px rgba(255, 0, 0, 0.8);
  border-color: #FF0000;
}
    .enemy-target.stoned {
  filter: grayscale(100%) brightness(0.7);
  border-color: #888 !important;
  box-shadow: none !important;
}
.enemy-target.snow {
  position: relative;
  overflow: visible;
}
.enemy-target.snow::before {
  content: "";
  position: absolute;
  bottom: -6px;
  left: 0;
  width: 100%;
  height: 14px;
  background: repeating-linear-gradient(
    to right,
    #ffffff 0 8px,
    #e8f6ff 8px 16px,
    #ffffff 16px 24px
  );

  border-radius: 0 0 6px 6px;
  pointer-events: none;
}
.enemy-target.snow::after {
  content: "";
  position: absolute;
  bottom: -6px;
  left: 0;
  width: 100%;
  height: 26px;

  background: #e8f6ff;
  mask: repeating-linear-gradient(
    to right,
    transparent 0 20px,
    black 20px 32px
  );
  clip-path: polygon(
    0 0,
    100% 0,
    100% 100%,
    50% 80%,
    0 100%
  );
}

    .burn-rocket-hud {
  box-shadow: 0 0 15px 5px orange !important;
  border: 2px solid orange !important;
  transition: box-shadow 0.3s ease;
}

.burn-mountain-hud {
  box-shadow: 0 0 15px 5px red !important;
  border: 2px solid red !important;
  transition: box-shadow 0.3s ease;
}
    #player-battle-status .hp-bar-container:last-of-type .hp-bar {
      background-color: #00FFFF;
    }
    #player-battle-status .hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.7em;
      text-shadow: 1px 1px 2px black;
      user-select: none;
    }

#game-hud { position: fixed; bottom: 0; left: 0; right: 0; z-index: 2000; }
#game-hud .hud-section#settings { text-align: center; padding: 0 1em; }


#settings-popup {
  display: none;
  position: absolute;    
  bottom: 46px;            
  left: 75%;
  transform: translateX(-50%);
  width: 280px;
  max-height: 380px;
  overflow-y: auto;
  background-color: #002591;
  color: white;
  border: 2px solid black;
  padding: 10px;
  box-sizing: border-box;
  z-index: 3000;
  font-size: 11px;
  box-shadow: 0 6px 12px rgba(0,0,0,0.6);
}


#settings-popup .item-use-button { font-family:"Press Start 2P",sans-serif; font-size:0.7em; padding:6px 8px; margin:2px 0; cursor:pointer; background:#2b2b2b; border:2px solid white; color:white; }
#settings-popup .item-use-button:hover { background:#0060ff; }


.settings-row { margin:8px 0; display:flex; align-items:center; justify-content:space-between; gap:8px; }
.settings-row label { font-size:10px; display:block; flex:1 1 auto; text-align:left; }
.settings-row .control { flex:0 0 auto; }

.settings-tooltip {
  font-size:10px;
  color:#ddd;
  margin-top:6px;
  background: rgba(0,0,0,0.2);
  padding:6px;
  border-radius:4px;
}
    #achievements-popup {
  left: 60%;
}

#party-popup {
  left: 20%;
}
  #general-inventory-list {
  display: grid;
  grid-template-rows: repeat(15, 25px); 
  grid-auto-flow: column; 
  grid-auto-columns: 240px; 
  gap: 10px;
  width: auto;
  max-width: 900px;
  max-height: 450px; 
  overflow-x: auto; 
  overflow-y: hidden;
  padding: 5px;
}

#general-inventory-list p {
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 11px;
  line-height: 25px; 
}
    #inventory-list {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  max-height: 250px;
  overflow-y: auto;  
}
  #inventory-popup.stats-popup {
  width: 900px;
  max-width: 900px;
  bottom: 100%;
  left: 100px;
}

    .inventory-item {
      display: flex;
      flex-direction: column;
      padding: 5px;
      border: 1px solid #555;
      border-radius: 3px;
      background-color: #55260e;
      color: white;
      min-width: 90px;
      user-select: none;
    }
    .inventory-popup {
      display: none;
      position: absolute;
      bottom: 200px;
      right: 100px;
      width: 250px;
      max-height: 300px;
      background-color: #55260e;
      border: 2px solid black;
      color: white;
      padding: 10px;
      text-align: left;
      overflow-y: auto;
      z-index: 1000;
      font-size: 0.75em;
    }
    .item-use-button {
      font-family: "Press Start 2P", sans-serif;
      font-size: 0.7em;
      padding: 2px 5px;
      cursor: pointer;
      margin-top: 5px;
      align-self: flex-start;
      background-color: #333;
      border: 1px solid white;
      color: white;
      user-select: none;
    }
    .item-use-button:hover {
      background-color: #555;
    }
    #equips-popup {
  position: fixed;               
  transform: translate(-50%, -50%); 
  width: 480px;
  height: 400px;
  background: #001a33;
  border: 4px solid white;
  z-index: 5000;      
  color: white;
  display: none;
  flex-direction: column;
  padding: 20px;
}


.slot-row { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; }
.equip-slot {
  width: 80px; height: 60px; border: 2px dashed #555; display: flex; 
  align-items: center; justify-content: center; font-size: 9px; cursor: pointer; text-align: center;
}
.equip-slot.filled { border: 2px solid white; background: #002591; }
#equips-list-display { 
  flex-grow: 1; border-top: 2px solid white; padding-top: 10px; overflow-y: auto; text-align: left;
}
.equip-item-row {
  display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid #333;
}

    *{
  cursor: url("cursor2.png") 6 0, auto;
}
    
button,
button:hover,
a,
a:hover,
.clickable,
.clickable:hover {
  cursor: url("pointer.png") 16 16, pointer !important;
}



    #game-over-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 2000;
}

.game-over-content {
  color: white;
  font-family: "Press Start 2P", sans-serif;
}

    #game-hud button {
      font-family: "Press Start 2P", sans-serif;
      padding: 8px 15px;
      cursor: pointer;
      background-color: #2b2b2b;
      border: 2px solid white;
      color: white;
      user-select: none;
      transition: background-color 0.3s ease;
    }
    #game-hud button:hover {
      background-color: #0060ff;
    }
  </style>
</head>
<body>

<div id="title-screen" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#001a33;z-index:3000;">
  <div style="text-align:center;color:white;">
    <h1 style="font-family:'Press Start 2P',sans-serif;margin-bottom:20px;">GAME TITLE</h1>
    
    <button id="play-button" style="font-family:'Press Start 2P',sans-serif;padding:12px 20px;font-size:14px;cursor:pointer;">Play</button>
    <br><br>
    <button id="load-title-button" style="font-family:'Press Start 2P',sans-serif;padding:12px 20px;font-size:14px;cursor:pointer;">Load Game</button>
  </div>

  <p style="
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    font-family:'Press Start 2P',sans-serif;
    font-size:12px;
    color:white;
    margin:0;
  ">
    Arrow/WASD to move, X to interact
  </p>
</div>


  <div id="prologue-overlay" style="
  display: none;
  position: fixed;
  inset: 0;
  background: black;
  z-index: 4000;
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
">
  <img id="prologue-image" src="" alt="Prologue" style="max-width: 90vw; max-height: 80vh; border: 4px solid white; border-radius: 8px;" />
  <button id="prologue-next" style="margin-top: 20px; font-family: 'Press Start 2P', sans-serif; padding: 10px 20px; cursor: pointer;">Next</button>
</div>


  <canvas id="game" width="640" height="480" tabindex="0"></canvas>

  <div id="game-hud">
  <div class="hud-section" id="stats">
    <p id="stats-button">Stats</p>
    <div id="stats-popup" class="stats-popup" style="display: none;">
      <h4>Player Stats</h4>
      <p>Level: <span id="popup-level"></span></p>
      <p>XP: <span id="popup-xp"></span></p>
      <p>Damage: <span id="popup-damage"></span></p>
    </div>
  </div>

  <div class="hud-section" id="player-status">
    <p> </p>
    <div id="hp-bar-container">
      <div id="hp-bar"></div>
      <div id="hp-text">16/16</div>
    </div>
  </div>

  <div class="hud-section" id="party">
    <p id="party-button">Party</p>
    <div id="party-popup" class="stats-popup" style="display: none;">
      <h4>Party</h4>
      <div id="party-list"></div>
      <div style="margin-top:8px;">
        <button id="equip-ally-button" class="item-use-button">Equip Selected Ally</button>
      </div>
    </div>
  </div>

  <div class="hud-section" id="inventory">
    <p id="inventory-button">Inventory</p>
    <div id="inventory-popup" class="stats-popup" style="display: none;">
      <h4>Inventory</h4>
      <div id="general-inventory-list"></div>
    </div>
  </div>

    <div class="hud-section" id="equips">
  <p id="equips-button" style="cursor:pointer;">Equips</p> 

  <div id="equips-popup" style="
    display:none; 
    position:fixed; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    width: 500px; 
    max-width: 90vw;
    height: 500px; 
    background: #001a33; 
    border: 4px solid white; 
    z-index: 5000; 
    color: white; 
    font-family: 'Press Start 2P'; 
    padding: 20px; 
    flex-direction: column;
    box-sizing: border-box;
    box-shadow: 0 0 100px rgba(0,0,0,0.8);
  ">
    
    <h2 style="text-align:center; font-size:16px; margin-bottom:10px;">Equipment & Gears</h2>
    <p id="equipping-target-name" style="text-align:center; font-size:10px; color:#aaa; margin-bottom:20px;">   </p>
    
    <div style="display:flex; justify-content:center; gap:10px; margin-bottom:30px;">
      <div id="slot-armor" class="equip-box" style="width:85px; height:70px; border:2px dashed #666; font-size:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; text-align:center; background: rgba(255,255,255,0.05);">Armor</div>
      <div id="slot-weapon" class="equip-box" style="width:85px; height:70px; border:2px dashed #666; font-size:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; text-align:center; background: rgba(255,255,255,0.05);">Weapon</div>
      <div id="slot-gear-0" class="equip-box" style="width:85px; height:70px; border:2px dashed #666; font-size:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; text-align:center; background: rgba(255,255,255,0.05);">Gear</div>
      <div id="slot-gear-1" class="equip-box" style="width:85px; height:70px; border:2px dashed #666; font-size:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; text-align:center; background: rgba(255,255,255,0.05);">Gear</div>
      <div id="slot-gear-2" class="equip-box" style="width:85px; height:70px; border:2px dashed #666; font-size:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; text-align:center; background: rgba(255,255,255,0.05);">Gear</div>
    </div>

    <div style="text-align:center; font-size:11px; border-bottom:2px solid white; padding-bottom:10px; margin-bottom:10px;">Available Items</div>

    <div id="equips-inventory-list" style="flex-grow:1; overflow-y:auto; padding-right:10px; text-align: left;">
    </div>

    <div style="text-align:center; margin-top:15px;">
      <button class="item-use-button" onclick="document.getElementById('equips-popup').style.display='none'">Close Menu</button>
    </div>
  </div>
</div>

    <div class="hud-section" id="achievements">
  <p id="achievements-button">Achievements</p>
  <div id="achievements-popup" class="stats-popup" style="display:none; max-height: 300px; overflow-y:auto;">
  </div>
</div>

  <div class="hud-section" id="settings">
    <p id="settings-button">
  <img src="settings.png" alt="Settings" style="width:32px; height:32px;">
</p>
    <div id="settings-popup" class="stats-popup" style="display:none; width:280px;">
      <h4>Settings</h4>

      <div style="margin:8px 0;">
        <label style="display:block; font-size:10px;">Difficulty</label>
        <select id="difficulty-select" style="width:100%; font-family:'Press Start 2P',sans-serif;">
          <option value="normal">Normal</option>
          <option value="hard">Hard</option>
          <option value="extreme">Extreme</option>
          <option value="ultimate">Ultimate</option>
        </select>
      </div>

      <div style="margin:8px 0;">
  <label style="display:block; font-size:10px;">Mobile Mode</label>
  <input id="toggle-mobile-mode" type="checkbox" /> Enable Mobile Controls
</div>

      <div style="margin:8px 0;">
  <label style="display:block; font-size:10px;">Autosave</label>
  <input id="toggle-autosave" type="checkbox" /> Enable Autosave<br>
  <input id="toggle-autosave-message" type="checkbox" /> Show Autosave Message
</div>


      <div style="margin:8px 0;">
        <label style="display:block; font-size:10px;">Save Slots</label>
        <div style="display:flex; gap:6px;">
          <button id="save-slot-1" class="item-use-button">Save 1</button>
          <button id="load-slot-1" class="item-use-button">Load 1</button>
        </div>
        <div style="display:flex; gap:6px; margin-top:6px;">
          <button id="save-slot-2" class="item-use-button">Save 2</button>
          <button id="load-slot-2" class="item-use-button">Load 2</button>
        </div>
        <div style="display:flex; gap:6px; margin-top:6px;">
          <button id="save-slot-3" class="item-use-button">Save 3</button>
          <button id="load-slot-3" class="item-use-button">Load 3</button>
        </div>
      </div>
    </div>
  </div>
</div>

  <div id="fade-overlay" style="position:fixed; inset:0; background:black; opacity:0; pointer-events:none; z-index:9999; transition: opacity 0.25s;"></div>


  <div id="battle-overlay">
    <div id="enemy-display"></div>
    <div id="player-battle-status"></div>
    <div id="battle-controls">
      <button id="attack-button">Attack</button>
      <button id="special-attack-button-1">SPECIAL 1 (100 STM)</button>
      <button id="special-attack-button-2">SPECIAL 2 (200 STM)</button>
      <button id="inventory-battle-button">Inventory</button>
    </div>
    <div id="inventory-battle-popup" class="inventory-popup" style="display: none;">
      <h4>Inventory</h4>
      <div id="inventory-list"></div>
    </div>
    </div>
      <div id="dialog-overlay" style="display:none; position:fixed; inset:0; z-index:2500;
     background:rgba(0,0,0,0.6); align-items:flex-end; justify-content:center; padding:20px;">
  <div id="dialog-box" style="background:#002591; color:white; border:2px solid black;
       padding:16px; max-width:640px; font-family:'Press Start 2P',sans-serif;">
    <div id="dialog-text" style="white-space:pre-wrap; font-size:12px; line-height:1.2;"></div>
    <div style="text-align:right; margin-top:8px;">
      <button id="dialog-next" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px;">Next</button>
    </div>
  </div>
</div>

  <div id="damage-overlay"></div>


<div id="export-menu" style="display:none;position:fixed;top:20%;left:50%;transform:translateX(-50%);
     background:#222;color:#fff;padding:20px;border:2px solid #fff;z-index:5000;">
  <h3>Exported Save</h3>
  <textarea id="export-box" rows="6" cols="60" readonly></textarea>
  <br>
  <button id="close-export">Close</button>
</div>



<div id="password-popup" style="display:none; position:fixed; inset:0; z-index:3000; background:rgba(0,0,0,0.8);">
  <div style="display:flex; flex-direction:column; justify-content:center; align-items:center; height:100%;">
    <div style="background:#002591; padding:20px; border:2px solid black; font-family:'Press Start 2P',sans-serif; color:white; width:300px; text-align:center;">
      <p>Enter 4-digit code:</p>
      <input id="password-input" type="password" maxlength="4" style="font-size:20px; text-align:center; width:100px;" />
      <div style="margin-top:15px;">
        <button id="password-submit" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px; cursor:pointer;">Submit</button>
        <button id="password-cancel" style="font-family:'Press Start 2P',sans-serif; padding:8px 12px; cursor:pointer; margin-left:10px;">Cancel</button>
      </div>
      <p id="password-message" style="color:#ff4444; margin-top:10px; height:18px;"></p>
    </div>
  </div>
</div>
  

  <div id="dev-console" style="display:none; position:fixed; top:10px; left:50%; transform:translateX(-50%); z-index:10000; width:400px; background:rgba(0,0,0,0.9); border:2px solid #00ff00; padding:10px; font-family:'monospace';">
  <div style="color:#00ff00; font-size:10px; margin-bottom:5px;">DEV CONSOLE: Type command and press Enter</div>
  <input id="dev-input" type="text" style="width:100%; background:#111; color:#00ff00; border:1px solid #00ff00; outline:none; font-family:'monospace';" placeholder="/help" />
</div>


  <div id="objective-box" style="
  position: fixed;
  top: 100px;
  right: 10px;
  width: 200px;
  background-color: #0047ab;
  color: white;
  border: 2px solid #002e6d;
  border-radius: 8px;
  padding: 15px;
  font-family: 'Press Start 2P', sans-serif;
  user-select: none;
  text-align: center;
  display: none;
">
  <div id="objective-title" style="font-weight: bold; font-size: 16px; margin-bottom: 10px;">Objective:</div>
  <div id="objective-text" style="font-size: 14px;">Explore the arcade area</div>
  <div id="objective-status" style="margin-top: 15px; font-size: 24px; color: #00FF00; display: none;">&#10003;</div>
</div>

  <div id="achievement-popup-box" style="
  position: fixed;
  top: 200px;
  right: 10px;
  width: 260px;
  background-color: #002591;
  color: white;
  border: 1px solid white;
  padding: 15px;
  font-family: 'Press Start 2P', sans-serif;
  z-index: 9000;
  display: none;
  opacity: 1;
  transition: opacity 1s ease-out;
  text-align: left;
">
  <div style="font-size: 10px; color: #00ffff; margin-bottom: 10px;">ACHIEVEMENT UNLOCKED</div>
  <div id="ach-popup-name" style="font-size: 12px; margin-bottom: 8px;"></div>
  <div id="ach-popup-desc" style="font-size: 8px; line-height: 1.4; opacity: 0.8;"></div>
</div>

  
<div id="mobile-controls" style="display:none; position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%); width: 220px; user-select:none; z-index: 3000;">

  <div style="display:flex; justify-content:center; margin-bottom: 6px;">
    <button id="btn-up" style="width: 60px; height: 60px;">▲</button>
  </div>
  <div style="display:flex; justify-content:center; gap: 10px;">
    <button id="btn-left" style="width: 60px; height: 60px;">◄</button>
    <button id="btn-interact" style="width: 60px; height: 60px;">X</button>
    <button id="btn-right" style="width: 60px; height: 60px;">►</button>
  </div>
  <div style="display:flex; justify-content:center; margin-top: 6px;">
    <button id="btn-down" style="width: 60px; height: 60px;">▼</button>
  </div>

</div>

<div id="game-over-overlay" style="display: none">
  <div class="game-over-content">
    <h1>Game Over</h1>
    <p>Press 'R' to Restart</p>
  </div>
</div>

  </div>

<script>
console.log('script loaded');

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');


canvas.tabIndex = 0;
canvas.focus();
canvas.addEventListener('click', () => canvas.focus());

const devMode = true;
// Player and game variables
let isGameOver = false;
let x = 150, y = 50;
const speed = 16;
const imageSize = 60;
const hitboxWidth = 30;
const hitboxHeight = 30;
const hitboxOffsetX = (imageSize - hitboxWidth) / 2;
const hitboxOffsetY = (imageSize - hitboxHeight) / 2;

  const useImage = true;

const playerSprites = {
  down: new Image(),
  up: new Image(),
  left: new Image(),
  right: new Image()
};

playerSprites.down.src = 'herodown.png';
playerSprites.up.src = 'heroup.png';
playerSprites.left.src = 'heroleft.png';
playerSprites.right.src = 'heroright.png';

let currentFacing = 'down';

const hpBar = document.getElementById('hp-bar');
const hpText = document.getElementById('hp-text');

let selectedEnemyIndex = 0;
let allyTargetMode = 'Current';
let gameFlags = {
  firsthit: false,
  isPowered: false,
  arcadegatetalk: false,
  arcadegate2: false,
  arcadeoldbottalk: false,
  arcadeoldbotNO: false,
  arcadeoldbottea: false,
  carpass: false,
  atticlever: false,
  birthdaybottalk: false,
  birthdaybotkilled: false,
  birthdaybotspared: false,
  louRecruited: false,
  interactedWithDeadBody: false,
  lightsFixed: false
};

let goodPoints = 0;
let badPoints = 0;


let shownDialogs = new Set();
let _dialogQueue = [];
let removedWallIds = new Set();
let removedInteractableIds = new Set();
let removedBattleZoneIds = new Set();
let openedChestIds = new Set(); 
let _battleDialogQueue = [];
let _battleDialogPausedState = null;


const zoneSprites = {
  fail: new Image (),
  robot: new Image(),
  bodyguard: new Image(),
  partygoers: new Image(),
  puncher: new Image(),
  mouse: new Image(),
  bossrobot: new Image()
};
zoneSprites.fail.src = 'fail.png';
  zoneSprites.bodyguard.src = 'bodyguard.png';
  zoneSprites.partygoers.src = 'partygoers.png';
  zoneSprites.puncher.src = 'puncher.png';
  zoneSprites.mouse.src = 'mouse.png';
zoneSprites.bossrobot.src = 'bossrobot.png';
zoneSprites.robot.src = 'robot.png';

function drawBreathing() {
  const t = Date.now() * 0.002;

  if (currentLevel && currentLevel.battleZones) {
    currentLevel.battleZones.forEach(zone => {
      if (!zone.sprite) return;
      const img = zoneSprites[zone.sprite];
      if (!img || !img.complete || img.naturalWidth === 0) return;

      const spriteW = Math.min(zone.width, 100);
      const spriteH = Math.min(zone.height, 100);
      const destX = zone.x + (zone.width - spriteW) / 2;
      const destY = zone.y + (zone.height - spriteH) / 2;

 
      const scaleY = 1.0 + Math.sin(t) * 0.08; 
      const currentH = spriteH * scaleY;
      
      const offsetHeight = currentH - spriteH;
      const drawY = destY - offsetHeight;

      ctx.drawImage(img, destX, drawY, spriteW, currentH);
    });
  }
}



let darkTimerMs = 0;
let darkTimerLimitMs = 30000;
let darkTimerTickInterval = null;
const darkTimerTickMs = 100;
let darkTimerActive = false;

let sliding = false;
let slidingDirection = { dx: 0, dy: 0 };
let slidingIntervalId = null;
const SLIDE_STEP_MS = 120; 




let _typingInterval = null;
let _isTyping = false;
let _fullTextToDisplay = "";
let _currentSpeaker = null;
  
let tempText = "";
let tempTextTimeout = null;
let defeatedZone = null;
let enemyAttackIntervalId = null;
let armorHealIntervalId = null;
let damageBoostTimer = null;
const ENEMY_ATTACK_DELAY = 2000;
let staminaRegenIntervalId = null;
let clickingInterval = null;
let inventory = new Map();
let extraLifeTimerId = null;
let battleRounds = 0;            
let currentRoundEncounters = [];     
let currentRoundIndex = 0;    


  let activeAmulets = {
  clicking: false,
  bullets: false,
  stamina: false,
  health: false,
  stealing: false,
  sacrifice: false,
  xp: false,
  defense: false
};

  const gearTypes = {
  hp_gear_1: { name: "HP Gear I", rarity: "common", hp: 5, desc: "+5 HP" },
  dmg_gear_1: { name: "Dmg Gear I", rarity: "common", dmg: 1, desc: "+1 Damage" },
  hp_gear_2: { name: "HP Gear II", rarity: "rare", hp: 8, desc: "+8 HP" },
  dmg_gear_2: { name: "Dmg Gear II", rarity: "rare", dmg: 2, desc: "+2 Damage" },
  hp_gear_3: { name: "HP Gear III", rarity: "super_rare", hp: 12, desc: "+12 HP" },
  dmg_gear_3: { name: "Dmg Gear III", rarity: "super_rare", dmg: 3, desc: "+3 Damage" },
  magnet_gear: { name: "Magnet Gear", rarity: "epic", desc: "Enemies drop +1 bolt" },
  steal_gear: { name: "Stealing Gear", rarity: "epic", desc: "Delay enemy attacks by 0.01s. Stackable" },
  vampire_gear: { name: "Vampire Gear", rarity: "mythic", desc: "Heals 10% HP for each kill" },
  statue_gear: { name: "Stone Gear", rarity: "mythic", desc: "Main attack has 1% to turn enemies to stone for 4s" }
};

const rarityColors = {
  common: "#ffffff", rare: "#2ecc71", super_rare: "#3498db", 
  epic: "#9b59b6", mythic: "#e74c3c", legendary: "#f39c12"
};

let equippedGears = [null, null, null];

  const armorTypes = {
  retro: { name: "Retro Armor", hpBonus: 0.10, passiveHealPercent: 0, desc: "+ 10% HP" },
  v8:    { name: "V8 Armor", hpBonus: 0.20, passiveHealPercent: 0, desc: "+ 20% HP" },
  saloon:{ name: "Saloon Armor", hpBonus: 0.40, passiveHealPercent: 0.02, desc: "+ 40% HP, heals 1% per sec" },
  haunted:{name: "Haunted Armor", hpBonus: 0.30, passiveHealPercent: 0, blockChance: 0.15, desc: "+ 30% HP, 30% chance to block" },
  virus: { name: "Virus Armor", hpBonus: 0.50, passiveHealPercent: 0, desc: "FORBIDDEN TO WEAR, TURN BACK 8-BIT, THERE IS STILL GOOD INSIDE YOU" }
};

const weaponTypes = {
  retro: { name: "Retro Weapon", dmgBonus: 0.10, desc: "+ 10% Damage" },
  v8:    { name: "V8 Weapon", dmgBonus: 0.20, desc: "+ 20% Damage" },
  saloon:{ name: "Saloon Weapon", dmgBonus: 0.15, desc: "+ 15% Damage" },
  haunted:{name: "Haunted Weapon", dmgBonus: 0.25, desc: "+ 25% Damage" },
  virus: { name: "Virus Weapon", dmgBonus: 0.50, desc: "DO NOT EQUIP, 8-BIT, THE EVIL IS CORRUPTING YOU" }
};

let equippedArmor = null; 
let equippedWeapon = null;

function applyEquipmentBonuses() {
  const baseMaxHp = playerStats.baseMaxHp;
  const baseDamage = playerStats.baseDamage;

  playerStats.maxHp = baseMaxHp;
  playerStats.damage = baseDamage;

  if (equippedArmor && armorTypes[equippedArmor]) {
    const armorBonusHp = Math.floor(baseMaxHp * armorTypes[equippedArmor].hpBonus);
    playerStats.maxHp = baseMaxHp + armorBonusHp;
  }

  if (equippedWeapon && weaponTypes[equippedWeapon]) {
    const weaponBonusDmg = Math.floor(baseDamage * weaponTypes[equippedWeapon].dmgBonus);
    playerStats.damage = baseDamage + weaponBonusDmg;
  }

  if (activeAlly) {
    activeAlly.maxHp = activeAlly.baseMaxHp;
    activeAlly.damage = activeAlly.baseDamage;
    activeAlly.currentHp = Math.min(activeAlly.currentHp, activeAlly.maxHp);
  }

  if (activeAmulets.sacrifice) {
    playerStats.maxHp = Math.floor(baseMaxHp * 1.5);
    if (activeAlly) {
      activeAlly.maxHp = Math.floor(activeAlly.baseMaxHp * 0.5);
      activeAlly.damage = Math.floor(activeAlly.baseDamage * 0.5);
    }
  }

  if (activeAmulets.xp) {
    playerStats.maxHp = Math.floor(baseMaxHp * 0.5);
    if (activeAlly) {
      activeAlly.maxHp = Math.floor(activeAlly.baseMaxHp * 0.5);
      activeAlly.damage = Math.floor(activeAlly.baseDamage * 0.5);
    }
  }

  equippedGears.forEach(gearId => {
    if (gearId && gearTypes[gearId]) {
      if (gearTypes[gearId].hp) playerStats.maxHp += gearTypes[gearId].hp;
      if (gearTypes[gearId].dmg) playerStats.damage += gearTypes[gearId].dmg;
    }
  });

  if (playerStats.currentHp > playerStats.maxHp) {
    playerStats.currentHp = playerStats.maxHp;
  }
  
  if (activeAlly) activeAlly.currentHp = Math.min(activeAlly.currentHp, activeAlly.maxHp);

  updateHp(playerStats.currentHp);
  updateStatsPopup();
}

fetch("inventory.json")
  .then(res => res.json())
  .then(data => {
    for (const [item, amount] of Object.entries(data)) {
      inventory.set(item, amount);
    }
  });


  const ABILITIES = {
  block: { cooldownMs: 12000, effectMs: 2400 },  
  counter: { cooldownMs: 8000, windowMs: 1200, stunMs: 3000 }, 
  cleanse: { cooldownMs: 15000 }                 
};

  let abilityCooldowns = {
  block: 0, 
  counter: 0,
  cleanse: 0
};
let abilityRegenIntervalId = null;
let blockActive = false;
let counterWindowActive = false;
  
let playerStats = {
  level: 1,
  currentHp: 16,
  maxHp: 16,
  damage: 2,
  xp: 0,
  xpToNextLevel: 10,
  currentStamina: 50,
  maxStamina: 200,
  baseMaxHp: 16,
  baseDamage: 2
};
  
const alliesData = [
  { id: 'ally1', name: 'Lou', baseMaxHp: 35, baseDamage: 3, attackIntervalMs: 1700, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally2', name: 'Buzz', baseMaxHp: 58, baseDamage: 4, attackIntervalMs: 2200, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally3', name: 'Colt', baseMaxHp: 23, baseDamage: 6, attackIntervalMs: 3000, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally4', name: 'Otis', baseMaxHp: 45, baseDamage: 4, attackIntervalMs: 2000, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally5', name: 'Janet', baseMaxHp: 40, baseDamage: 3, attackIntervalMs: 1500, level: 1, xp: 0, xpToNextLevel: 10 },
  { id: 'ally6', name: 'Max', baseMaxHp: 36, baseDamage: 4, attackIntervalMs: 1000, level: 1, xp: 0, xpToNextLevel: 10 },
];

let unlockedAllies = new Set();
let equippedAllyId = null;      
let activeAlly = null;           
let allyAttackTimerId = null; 

  
let inBattle = false;

let enemyTypes = {};

fetch("enemies.json")
  .then(res => res.json())
  .then(data => {
    enemyTypes = data;
  });


  const speakerConfigs = {
  '8-Bit': { speed: 30, pitch: 1.0, frequency: 2, sound: 'blip.wav' },
  'New': { speed: 30, pitch: 1.0, frequency: 2, sound: 'blub2.mp3' },
  'Birthday Bot': { speed: 30, pitch: 1.7, frequency: 3, sound: 'blip.wav' },
  'BossRobot': { speed: 30, pitch: 0.6, frequency: 2, sound: 'blip.wav' }, 
  'Bodyguard': { speed: 30, pitch: 0.7, frequency: 1, sound: 'blip.wav' },
  'Guard': { speed: 40, pitch: 0.6, frequency: 1, sound: 'blip.wav' },
  'default': { speed: 30, pitch: 1.0, frequency: 2, sound: 'blip.wav' }
};


  // want multiple rounds? just do {
    //x: 507, y: 70, width: 64, height: 64,
    //encounter: [
      //[ { type: "Sniperbot" }, { type: "Sniperbot" } ], // round 1
      //[ { type: "Puncherbot" }, { type: "Sniperbot" } ]   // round 2
    //],
    //sprite: 'fail'
  //}
  
const levels = [
  {
    bgSrc: "arcadebg.png",
    walls: [
      { x: 0, y: 0, width: 640, height: 20 },
      { x: 0, y: 460, width: 640, height: 20 },
    ],
    doors: [
      { x: 0, y: 0, width: 1, height: 1, destLevel: 1, destX: 300, destY: 375 }
    ],
    darkZones: [],
    battleZones: [],
    dialogZones: [],
    interactables: []
  }
];

let currentLevelIndex = 0;
let currentLevel = levels[currentLevelIndex];
 
levels.forEach(level => {
  level.walls.forEach((wall, idx) => {
    if (!wall.id) wall.id = `wall_${idx}`;
  });
});

  const achievements = [
  {
    id: 'played',
    name: 'Demo Player',
    description: 'Played the demo of the game!',
    target: 1,      // set your number here
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['played'].progress >= 1
  },
  {
    id: 'kill_enemies',
    name: 'Bot Killer',
    description: 'Kill 50 enemies',
    target: 50,      // set your number here
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_enemies'].progress >= achievementsMap['kill_enemies'].target
  },
    {
    id: 'kill_enemies2',
    name: 'Bot Slayer',
    description: 'Kill 100 enemies',
    target: 100,      // set your number here
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_enemies2'].progress >= achievementsMap['kill_enemies2'].target
  },
    {
    id: 'kill_enemies3',
    name: 'No More Robots',
    description: 'Kill 1000 enemies',
    target: 1000,      // set your number here
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_enemies3'].progress >= achievementsMap['kill_enemies3'].target
  },
  {
    id: 'open_chests',
    name: 'Treasure Opener',
    description: 'Open 10 chests',
    target: 10,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['open_chests'].progress >= achievementsMap['open_chests'].target
  },
    {
    id: 'kill_tutorial_dummy',
    name: 'Tutorial Beaten',
    description: 'Kill the tutorial dummy enemy',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_tutorial_dummy'].progress >= 1
  },
    {
    id: 'tp_beat_master',
    name: 'Sharp Shot',
    description: 'Beat Unit 318920s score in Target Practice',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['tp_beat_master'].progress >= 1
  },
    {
    id: 'kill_bossbot',
    name: 'Boss Slayer',
    description: 'Kill the Boss Robot on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_bossbot'].progress >= 1
  },
  {
    id: 'kill_icebot',
    name: 'Ice Lord',
    description: 'Kill Frozen Metal on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_icebot'].progress >= 1
  },
  {
    id: 'kill_lifestealboss',
    name: 'Undertaker',
    description: 'Kill the Soul Slasher on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_lifestealboss'].progress >= 1
  },
  {
    id: 'kill_critboss',
    name: 'High Noon',
    description: 'Kill Deadshot on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_critboss'].progress >= 1
  },
    {
    id: 'kill_caveboss',
    name: 'Reduced to Pebbles',
    description: 'Kill Stoneforce on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_caveboss'].progress >= 1
  },
    {
    id: 'kill_mountainboss',
    name: 'Last Fire Breath',
    description: 'Kill Autoyvern on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_mountainboss'].progress >= 1
  },
    {
    id: 'kill_islandboss',
    name: 'Washed Up Guardian',
    description: 'Kill Nekark of the Seas on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_islandboss'].progress >= 1
  },
    {
    id: 'kill_factoryboss',
    name: 'Fireworks',
    description: 'Kill The Works Plant on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_factoryboss'].progress >= 1
  },
  {
    id: 'kill_ghostboss',
    name: 'Whack-a-ghost',
    description: 'Kill The Maestro on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_ghostboss'].progress >= 1
  },
    {
    id: 'kill_finaleboss',
    name: 'Save the World!',
    description: 'Kill Corruptus Caliginis Aeternae on Ultimate Difficulty',
    target: 1,
    progress: 0,
    unlocked: false,
    checkCondition: () => achievementsMap['kill_finaleboss'].progress >= 1
  }
];

const achievementsMap = {};
achievements.forEach(a => achievementsMap[a.id] = a);
  
  const titleScreen = document.getElementById('title-screen');
const playBtn = document.getElementById('play-button');
  
let bgImg = new Image();
bgImg.src = 'arcade.png';
const playerImg = new Image();
playerImg.src = '8bit.png'; 

function preloadImagesForLevel(levelIndex, onComplete) {
  const level = levels[levelIndex];
  
  bgImg = new Image();
  bgImg.onload = () => {

    if (playerSprites.down.complete) {
      onComplete();
    } else {
      playerSprites.down.onload = () => onComplete();
    }
  };
  bgImg.src = level.bgSrc;
}
  
const objectiveBox = document.getElementById('objective-box');
const objectiveTextEl = document.getElementById('objective-text');
const objectiveStatusEl = document.getElementById('objective-status');

let currentObjective = null;
let objectiveCompleted = false;

function setObjective(text) {
  currentObjective = text;
  objectiveCompleted = false;
  objectiveTextEl.textContent = text;
  objectiveStatusEl.style.display = 'none';
  objectiveBox.style.backgroundColor = '#0047ab'; 
}

function completeObjective() {
  objectiveCompleted = true;
  objectiveStatusEl.style.display = 'block'; 
  objectiveBox.style.backgroundColor = '#37eb00';
}

setObjective("Current Task");


function objPlaceholder() {
  if (currentObjective === "Current Task") {
    completeObjective();
    setTimeout(() => {
      setObjective("new objective");
    }, 3000);
  }
}
  const blipSound = new Audio('blip.wav');
blipSound.volume = 0.6;
  
function startTypewriter(text, element, speaker = null, effect = null, onFinish = null) {
  clearInterval(_typingInterval);
  _isTyping = true;
  _fullTextToDisplay = text;
  _currentSpeaker = speaker;
  _currentEffect = effect;
  _currentOnFinish = onFinish;

  const config = speakerConfigs[speaker] || speakerConfigs['default'];
  const charSound = new Audio(config.sound);
  charSound.volume = 0.5;

  let i = 0;
  element.innerHTML = speaker ? `<strong>${speaker}</strong>\n\n` : "";

  _typingInterval = setInterval(() => {
    if (i < text.length) {
      const char = text.charAt(i);
      const span = document.createElement('span');
      span.className = 'dialog-char';
      span.textContent = char;
      if (effect === 'shaky') span.classList.add('effect-shake');
      if (effect === 'sine' || effect === 'wave') {
          span.classList.add('effect-wave');
          span.style.animationDelay = (i * 0.1) + 's';
      }
      if (effect === 'glitch') span.classList.add('effect-glitch');
      element.appendChild(span);

      if (i % config.frequency === 0) {
        const playClone = charSound.cloneNode();
        playClone.playbackRate = config.pitch;
        playClone.play().catch(e => {});
      }
      i++;
    } else {
      finishTyping(element, onFinish);
    }
  }, config.speed);
}

function finishTyping(element, onFinish = null) {
  clearInterval(_typingInterval);
  _isTyping = false;
  
  element.innerHTML = _currentSpeaker ? `<strong>${_currentSpeaker}</strong>\n\n` : "";
  for (let i = 0; i < _fullTextToDisplay.length; i++) {
    const span = document.createElement('span');
    span.className = 'dialog-char';
    span.textContent = _fullTextToDisplay[i];
    if (_currentEffect === 'shaky') span.classList.add('effect-shake');
    if (_currentEffect === 'sine' || _currentEffect === 'wave') {
        span.classList.add('effect-wave');
        span.style.animationDelay = (i * 0.1) + 's';
    }
    if (_currentEffect === 'glitch') span.classList.add('effect-glitch');
    element.appendChild(span);
  }
  if (onFinish) onFinish();
}
  
function findDialogZone(checkX, checkY) {
  const hitboxX = checkX + (typeof hitboxOffsetX !== 'undefined' ? hitboxOffsetX : 0);
  const hitboxY = checkY + (typeof hitboxOffsetY !== 'undefined' ? hitboxOffsetY : 0);
  const hw = typeof hitboxWidth !== 'undefined' ? hitboxWidth : 16;
  const hh = typeof hitboxHeight !== 'undefined' ? hitboxHeight : 16;
  const level = currentLevel;
  if (!level || !level.dialogZones) return null;
  for (const zone of level.dialogZones) {
    if (!zone || !zone.id) continue;
    if (shownDialogs.has(zone.id)) continue;
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hw > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hh > zone.y
    ) return zone;
  }
  return null;
}


function normalizeDialogLines(textOrLines, defaultStyle) {
  const lines = Array.isArray(textOrLines) ? textOrLines.slice() : [String(textOrLines)];
  return lines.map(line => {
    if (typeof line === 'string') {
      return { speaker: null, text: line, style: defaultStyle || 'dialog', effect: null };
    }
    return {
      speaker: line.speaker || null,
      text: line.text != null ? String(line.text) : '',
      style: line.style || defaultStyle || 'dialog',
      effect: line.effect || null
    };
  });
}

function applyDialogStyle(box, style) {
  box.style.maxWidth = '640px';
  box.style.fontSize = '12px';
  if (style === 'other') {
    box.style.background = '#223344';
    box.style.fontSize = '14px';
  } else if (style === 'lou') {
    box.style.background = '#78bdff';
    box.style.fontSize = '14px';
  } else if (style === 'npc') {
    box.style.background = '#b7b7b7';
    box.style.fontSize = '14px';
  } else if (style === 'unit') {
    box.style.background = '#4c4c4c';
    box.style.fontSize = '14px';
  } else if (style === 'boss') {
    box.style.background = '#330000';
    box.style.fontSize = '12px';
    } else if (style === 'colt') {
    box.style.background = '#ca2f2f';
    box.style.fontSize = '12px';
  } else {
    box.style.background = '#0e2057';
    box.style.fontSize = '12px';
  }
}
function findNearbyDialogZone(px, py) {

  const level = currentLevel;
  if (!level || !level.dialogZones) return null;
  const hitboxX = px + (typeof hitboxOffsetX !== 'undefined' ? hitboxOffsetX : 0);
  const hitboxY = py + (typeof hitboxOffsetY !== 'undefined' ? hitboxOffsetY : 0);
  const hw = typeof hitboxWidth !== 'undefined' ? hitboxWidth : 16;
  const hh = typeof hitboxHeight !== 'undefined' ? hitboxHeight : 16;
  for (const zone of level.dialogZones) {
    if (!zone || !zone.id) continue;
    if (shownDialogs.has(zone.id)) continue;
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hw > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hh > zone.y
    ) return zone;
  }
  return null;
}

function showDialogWithOptions(dialogText, options, idToMark, opts = {}) {
  const overlay = document.getElementById('dialog-overlay');
  const box = document.getElementById('dialog-box');
  const textDiv = document.getElementById('dialog-text');
  const nextBtn = document.getElementById('dialog-next');

  overlay.style.display = 'flex';
  overlay._markId = idToMark || null;
  nextBtn.style.display = 'none';

  applyDialogStyle(box, opts.style || 'dialog');

  startTypewriter(dialogText, textDiv, opts.speaker || null, opts.effect, () => {
    textDiv.appendChild(document.createElement('br'));
    textDiv.appendChild(document.createElement('br'));

    options.forEach(opt => {
      const btn = document.createElement('button');
      btn.textContent = opt.label;
      btn.className = 'item-use-button';
      btn.style.margin = '8px 10px 0 0';
      btn.style.padding = '8px 16px';
      btn.style.fontSize = '14px';
      btn.onclick = () => {
        overlay.style.display = 'none';
        if (opt.onSelect) opt.onSelect();
        if (idToMark) shownDialogs.add(idToMark);
        draw();
      };
      textDiv.appendChild(btn);
    });
  });
}
  
  function showBattleDialog(textOrLines, idToMark, opts = {}) {
  document.getElementById('dialog-next').style.display = 'inline-block';
  const overlay = document.getElementById('dialog-overlay');
  const box = document.getElementById('dialog-box');
  const textDiv = document.getElementById('dialog-text');
  const fallbackStyle = opts.style || 'dialog';

  pauseBattleTimersForDialog();

  const lines = Array.isArray(textOrLines) ? textOrLines.slice() : [textOrLines];
  _battleDialogQueue = lines.map(l => {
     if (typeof l === 'string') return { speaker: null, text: l, style: fallbackStyle };
     return { speaker: l.speaker || null, text: l.text, style: l.style || fallbackStyle };
  });

  if (_battleDialogQueue.length > 0) {
    const line = _battleDialogQueue.shift();
    overlay.style.display = 'flex';
    applyDialogStyle(box, line.style);
    startTypewriter(line.text, textDiv, line.speaker, line.effect);
  }
}

function showDialog(textOrLines, idToMark, opts = {}) {
  document.getElementById('dialog-next').style.display = 'inline-block';
  const overlay = document.getElementById('dialog-overlay');
  const box = document.getElementById('dialog-box');
  const textDiv = document.getElementById('dialog-text');
  const defaultStyle = opts.style || 'dialog';

  overlay.style.display = 'flex';
  _dialogQueue = normalizeDialogLines(textOrLines, defaultStyle);

  if (_dialogQueue.length > 0) {
    const line = _dialogQueue.shift();
    applyDialogStyle(box, line.style);
    
    startTypewriter(line.text, textDiv, line.speaker, line.effect);
  }
  
  overlay._markId = idToMark || null;
  overlay._onComplete = opts.onComplete || null; 
  draw();
}

const prologueOverlay = document.getElementById('prologue-overlay');
const prologueImage = document.getElementById('prologue-image');
const prologueNext = document.getElementById('prologue-next');

const prologueImages = [
  'prologue1.png',
  'prologue2.png',
  'prologue3.png',
  'prologue4.png'
];

let prologueIndex = 0;

playBtn.addEventListener('click', () => {
  titleScreen.style.display = 'none';


  prologueIndex = 0;
  prologueImage.src = prologueImages[prologueIndex];
  prologueOverlay.style.display = 'flex';
});

prologueNext.addEventListener('click', () => {
  prologueIndex++;
  if (prologueIndex < prologueImages.length) {
    prologueImage.src = prologueImages[prologueIndex];
  } else {
    prologueOverlay.style.display = 'none';


    if (objectiveBox) objectiveBox.style.display = 'block';

   
    currentLevelIndex = 0;
    currentLevel = levels[currentLevelIndex];
    x = typeof x === 'number' ? x : 150;
    y = typeof y === 'number' ? y : 50;

    preloadImagesForLevel(currentLevelIndex, () => {
      draw();
      achievementsMap['played'].progress++;
      checkAchievements();
      updateAbilityButtonsUI();
      showDialog([
      { speaker: '8-Bit', text: "Ughhhh...", style: 'dialog' },
      { speaker: '8-Bit', text: "I woke up in so much pain...", style: 'dialog' },
      { speaker: '8-Bit', text: "I guess I gotta explore.", style: 'dialog' }
    ]);
    });
  }
});


const closedChestImg = new Image(); closedChestImg.src = "chest_closed.png";
const openChestImg   = new Image(); openChestImg.src = "chest_open.png";

const stoneImg = new Image();
stoneImg.src = "stone.png";

const hammerImg = new Image();
hammerImg.src = "hammer.png";

const steelBlockImg = new Image();
steelBlockImg.src = 'steel_block.png';

const laserCutterImg = new Image();
laserCutterImg.src = 'laser_cutter.png';

const keycardImg = new Image();
keycardImg.src = 'keycard.png';

const gasMaskImg = new Image();
gasMaskImg.src = 'gas_mask.png';

const raftImg = new Image();
raftImg.src = 'raft.png';

const torchImg = new Image();
torchImg.src = 'torch.png';

const drillImg = new Image();
drillImg.src = 'drill.png';

const blockadeImg = new Image();
blockadeImg.src = 'blockade.png';

const aOldBotImg = new Image();
aOldBotImg.src = 'arcadeoldbot.png';

const dmgPotionImg = new Image();
dmgPotionImg.src = 'dmgPotion.png';

const stmPotionImg = new Image();
stmPotionImg.src = 'stmPotion.png';

const arcadegateImg = new Image();
arcadegateImg.src = 'arcadegate.png';

const partybotImg = new Image();
partybotImg.src = 'partybot.png';

const rockbImg = new Image();
rockbImg.src = 'rockB.png';

const leverOnImg = new Image();
leverOnImg.src = 'leveron.png';
const leverOffImg = new Image();
leverOffImg.src = 'leveroff.png';


let activeEnemies = [];

function wrapText(context, text, x, y, maxWidth, lineHeight) {
  const words = String(text).split(' ');
  let line = "";
  for (let n = 0; n < words.length; n++) {
    const testLine = line ? (line + " " + words[n]) : words[n];
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      context.fillText(line.trim(), x, y);
      line = words[n];
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  context.fillText(line.trim(), x, y);
}

function showTemporaryText(message) {
  tempText = message;
  if (tempTextTimeout) clearTimeout(tempTextTimeout);
  tempTextTimeout = setTimeout(() => {
    tempText = "";
    draw();
  }, 3000);
}

  
function canGoBelow1Hp() {
  return extraLifeTimerId === null;
}

function updateStamina(newStamina) {
  if (newStamina < 0) newStamina = 0;
  if (newStamina > playerStats.maxStamina) newStamina = playerStats.maxStamina;
  playerStats.currentStamina = newStamina;
}

function updateHp(newHealth) {
  if (newHealth < 0) newHealth = 0;
  if (newHealth > playerStats.maxHp) newHealth = playerStats.maxHp;

  playerStats.currentHp = newHealth;

  const newWidth = (playerStats.currentHp / playerStats.maxHp) * 100;
  hpBar.style.width = `${newWidth}%`;
  hpText.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;
}

function updateStatsPopup() {
  document.getElementById('popup-level').textContent = playerStats.level;
  document.getElementById('popup-xp').textContent = `${playerStats.xp} / ${playerStats.xpToNextLevel}`;
  document.getElementById('popup-damage').textContent = playerStats.damage;
}

const passwordPopup = document.getElementById('password-popup');
const passwordInput = document.getElementById('password-input');
const passwordSubmit = document.getElementById('password-submit');
const passwordCancel = document.getElementById('password-cancel');
const passwordMessage = document.getElementById('password-message');

let currentPasswordDoor = null;

function openPasswordPopup(doorObj) {
  currentPasswordDoor = doorObj;
  passwordInput.value = "";
  passwordMessage.textContent = "";
  passwordPopup.style.display = 'flex';
  passwordInput.focus();
}

function closePasswordPopup() {
  passwordPopup.style.display = 'none';
}

passwordSubmit.addEventListener('click', () => {
  if (!currentPasswordDoor) {
    console.error('No password door assigned');
    return;
  }

  const entered = passwordInput.value;

  if (entered === currentPasswordDoor.passcode) {
    showTemporaryText('Access granted!');
    closePasswordPopup();

    if (typeof currentPasswordDoor.destLevel === 'number') {
      loadLevel(currentPasswordDoor.destLevel, currentPasswordDoor.destX, currentPasswordDoor.destY);
    } else {
      console.error('Destination level is invalid or missing');
    }

    currentLevel.interactables = currentLevel.interactables.filter(o => o !== currentPasswordDoor);
    draw();
  } else {
    passwordMessage.textContent = "Incorrect code!";
  }
});

passwordCancel.addEventListener('click', () => {
  closePasswordPopup();
});

function levelUpAlly(ally) {
  let leveled = false;
  
  while (ally.xp >= ally.xpToNextLevel) {
    leveled = true;
    ally.level++;
    ally.xp -= ally.xpToNextLevel;
    ally.xpToNextLevel = Math.floor(ally.xpToNextLevel * 1.2);

    ally.baseMaxHp += Math.floor(3 + (ally.level / 2));
    ally.baseDamage += Math.floor(1 + (ally.level / 6));
  }

  if (leveled) {
    ally.maxHp = ally.baseMaxHp;
    ally.currentHp = ally.maxHp;
    showTemporaryText(`${ally.name} reached Level ${ally.level}!`);
    
    const masterAlly = alliesData.find(a => a.id === ally.id);
    if (masterAlly) {
      masterAlly.level = ally.level;
      masterAlly.xp = ally.xp;
      masterAlly.xpToNextLevel = ally.xpToNextLevel;
      masterAlly.baseMaxHp = ally.baseMaxHp;
      masterAlly.baseDamage = ally.baseDamage;
    }
    
    drawPartyStatus();
  }
}


function levelUp() {
  playerStats.level++;
  playerStats.xp -= playerStats.xpToNextLevel;
  playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5);

  playerStats.baseMaxHp += Math.floor(3 + (playerStats.level / 1));
  playerStats.baseDamage = Math.min(20, playerStats.baseDamage + 1);

  applyEquipmentBonuses();

  playerStats.currentHp = playerStats.maxHp;
  updateHp(playerStats.currentHp);

  updateStatsPopup();
  showTemporaryText(`Leveled up to ${playerStats.level}!`);
}


function gainXP(amount) {
  const mult = getDifficultyMultipliers();
  let xp = Math.floor(amount * mult.xpMult);
  
  if (activeAmulets.xp) xp *= 1.5;
  
  playerStats.xp += Math.floor(xp);

  if (activeAlly) {
    activeAlly.xp += Math.floor(xp);

    const masterAlly = alliesData.find(a => a.id === activeAlly.id);
    if (masterAlly) {
      masterAlly.xp = activeAlly.xp; 
    }
    while (activeAlly.xp >= activeAlly.xpToNextLevel) {
      levelUpAlly(activeAlly);
    }
  }

  if (playerStats.xp >= playerStats.xpToNextLevel) {
    levelUp();
  }
  
  updateStatsPopup();
  drawPartyStatus();
  
}

function removeZone(zone) {
  if (!zone) return;
  if (zone.type === 'battleZone') {
    const index = currentLevel.battleZones.indexOf(zone.object);
    if (index > -1) {
      if (zone.object.id) {
        removedBattleZoneIds.add(zone.object.id);
      }
      currentLevel.battleZones.splice(index, 1);
    }
  } else if (zone.type === 'interactable') {
    const index = currentLevel.interactables.indexOf(zone.object);
    if (index > -1) {
      if (zone.object.id) removedInteractableIds.add(zone.object.id);
      currentLevel.interactables.splice(index, 1);
    }
  }
}

  function arraysEqual(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) return false;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
  return true;
}

function findLeversInGroup(groupId) {
  if (!groupId) return [];
  const arr = [];
  (currentLevel.interactables || []).forEach(obj => {
    if (obj && obj.action === 'lever' && obj.leverType === 'multi' && obj.groupId === groupId) {
      
      if (typeof obj.currentState === 'undefined') obj.currentState = !!obj.initialState;
      arr[obj.indexInGroup] = obj;
    }
  });
  return arr;
}

function toggleWallById(wallId, present, levelIndex = currentLevelIndex) {
  if (!wallId) return;
  const level = levels[levelIndex];
  if (!level) return;
  const walls = level.walls || [];
  const idx = walls.findIndex(w => w.id === wallId);
  if (present) {
    if (idx === -1) {
    }
  } else {
    if (idx !== -1) {
      removedWallIds.add(wallId);
      walls.splice(idx, 1);
    }
  }
}

function evaluateMultiLeverGroup(groupId, controllerObj = null) {
  const levers = findLeversInGroup(groupId);
  if (!levers.length) {
    showTemporaryText('Nothing happens.');
    return;
  }
  const currentCombo = levers.map(l => !!(l && l.currentState));
  const controller = controllerObj || (currentLevel.interactables || []).find(o => o.action === 'lever_controller' && o.groupId === groupId);
  if (!controller || !Array.isArray(controller.targetCombo)) {
    showTemporaryText('This lever group is not configured.');
    return;
  }
  const target = controller.targetCombo.map(v => !!v);
  const matches = arraysEqual(currentCombo, target);
  if (matches) {
    showTemporaryText('Correct combination!');
    if (controller.linkedWallId) toggleWallById(controller.linkedWallId, false);
  } else {
    showTemporaryText('Nothing happens.');
    if (controller.linkedWallId) toggleWallById(controller.linkedWallId, true);
  }
  draw();
}


function getDifficultyMultipliers() {
  if (gameSettings.difficulty === 'hard') {
    return { enemyHp: 1, enemyDmg: 2, xpMult: 1.3 };
  } else if (gameSettings.difficulty === 'extreme') {
    return { enemyHp: 2, enemyDmg: 2, xpMult: 2.0 }; 
  } else if (gameSettings.difficulty === 'ultimate') {
    return { enemyHp: 3, enemyDmg: 3, xpMult: 4.0 };
  }
  return { enemyHp: 1, enemyDmg: 1, xpMult: 1.0 }; 
}


function scaleEnemyStats(baseStats) {
  const mult = getDifficultyMultipliers();
  return {
    ...baseStats,
    maxHp: Math.max(1, Math.floor((baseStats.maxHp + Math.floor(currentLevelIndex / 2)) * mult.enemyHp)),
    damage: Math.max(0, Math.floor((baseStats.damage + Math.floor(currentLevelIndex / 3)) * mult.enemyDmg))
  };
}


  

const inventoryButton = document.getElementById('inventory-button');
const inventoryPopup = document.getElementById('inventory-popup');
const statsPopup = document.getElementById('stats-popup');
const inventoryList = document.getElementById('general-inventory-list');

inventoryButton.addEventListener('click', () => {
  
  if (inBattle || isGameOver) return;

  
  if (statsPopup) statsPopup.style.display = 'none';

 
  const isHidden = window.getComputedStyle(inventoryPopup).display === 'none';
  if (isHidden) {
    drawGeneralInventory();
    inventoryPopup.style.display = 'block';
  } else {
    inventoryPopup.style.display = 'none';
  }
});

function drawGeneralInventory() {
  inventoryList.innerHTML = "";
  const allZero = inventory.size === 0 || Array.from(inventory.values()).every(q => q === 0);
  if (allZero) {
    inventoryList.innerHTML = '<p>Your inventory is empty.</p>';
    return;
  }
  inventory.forEach((quantity, itemName) => {
    if (quantity > 0) {
      const p = document.createElement('p');
      p.textContent = `${itemName.replace(/_/g, ' ')}: ${quantity}`;
      inventoryList.appendChild(p);
    }
  });
}


function findBattleZone(checkX, checkY) {
  const hitboxX = checkX + hitboxOffsetX;
  const hitboxY = checkY + hitboxOffsetY;
  
  if (!currentLevel.battleZones) return null;
  
  for (const zone of currentLevel.battleZones) {
    const r = zone.interactRect || { 
      x: zone.x, 
      y: zone.y, 
      width: zone.width, 
      height: zone.height 
    };

    if (
      hitboxX < r.x + r.width &&
      hitboxX + hitboxWidth > r.x &&
      hitboxY < r.y + r.height &&
      hitboxY + hitboxHeight > r.y
    ) {
      return zone;
    }
  }
  return null;
}

function showGameOver() {
  isGameOver = true;
  if (enemyAttackIntervalId) clearInterval(enemyAttackIntervalId);
  if (staminaRegenIntervalId) clearInterval(staminaRegenIntervalId);
  document.getElementById('battle-overlay').style.display = 'none';
  document.getElementById('game-over-overlay').style.display = 'flex';
}


function drawInventoryBattlePopup() {
 
console.log('drawInventoryBattlePopup called, entries:', Array.from(inventory.entries()));

  const battleInventoryList = document.getElementById('inventory-list');
  battleInventoryList.innerHTML = "";

 
  const allowedExact = new Set(['bandaid','emp_grenade','poison_vial','extra_life', 'damage_potion', 'stamina_potion', 'anti_virus', 'driftwood']);
  const allowedPrefix = ['battle_']; 

  
  const entries = [];
  inventory.forEach((quantity, itemName) => {
    if (!quantity || quantity <= 0) return;
    if (allowedExact.has(itemName)) {
      entries.push({ itemName, quantity });
      return;
    }
    for (const p of allowedPrefix) {
      if (itemName.startsWith(p)) { entries.push({ itemName, quantity }); break; }
    }
  });

  if (entries.length === 0) {
    battleInventoryList.innerHTML = '<p>Inventory is empty.</p>';
    return;
  }

  for (const { itemName, quantity } of entries) {
    const itemElement = document.createElement('div');
    itemElement.className = 'inventory-item';
    itemElement.innerHTML = `<span>${itemName.replace(/_/g,' ')} (${quantity})</span>`;

    const useButton = document.createElement('button');
    useButton.textContent = 'Use';
    useButton.className = 'item-use-button';
    useButton.onclick = () => useItem(itemName);
    itemElement.appendChild(useButton);

    battleInventoryList.appendChild(itemElement);
  }
}

  const partyButton = document.getElementById('party-button');
const partyPopup = document.getElementById('party-popup');
const partyListDiv = document.getElementById('party-list');
const equipAllyButton = document.getElementById('equip-ally-button');

partyButton.addEventListener('click', () => {
  if (partyPopup.style.display === 'none') {
    drawPartyList();
    partyPopup.style.display = 'block';
  } else {
    partyPopup.style.display = 'none';
  }
});

function drawPartyList() {
  partyListDiv.innerHTML = '';
  if (unlockedAllies.size === 0) {
    partyListDiv.innerHTML = '<p>No allies unlocked yet.</p>';
    equipAllyButton.disabled = true;
    return;
  }

  equipAllyButton.disabled = false;

  unlockedAllies.forEach(allyId => {
    const ally = alliesData.find(a => a.id === allyId);
    if (!ally) return;

    const div = document.createElement('div');
    div.className = 'party-ally-item';
    div.textContent = `${ally.name} (Lvl ${ally.level}, HP: ${ally.baseMaxHp}, DMG: ${ally.baseDamage})`;
    div.dataset.allyId = ally.id;
    div.style.cursor = 'pointer';

    if (ally.id === equippedAllyId) {
      div.style.fontWeight = 'bold';
      div.style.color = 'yellow';
    }

    div.onclick = () => {
      const prevSelected = partyListDiv.querySelector('.selected');
      if (prevSelected) prevSelected.classList.remove('selected');
      div.classList.add('selected');
    };

    partyListDiv.appendChild(div);
  });
}

equipAllyButton.addEventListener('click', () => {
  const selectedDiv = partyListDiv.querySelector('.selected');
  if (!selectedDiv) {
    showTemporaryText('Select an ally to equip.');
    return;
  }
  const allyId = selectedDiv.dataset.allyId;
  if (!unlockedAllies.has(allyId)) {
    showTemporaryText('This ally is not unlocked.');
    return;
  }
  equippedAllyId = allyId;
  showTemporaryText(`Equipped ${alliesData.find(a => a.id === allyId).name} as ally.`);
  partyPopup.style.display = 'none';
  drawPartyList();
});

function equipArmor(type) {
  if (!armorTypes[type]) {
    showTemporaryText(`Unknown armor type: ${type}`);
    return;
  }
  if ((inventory.get(`armor_${type}`) || 0) <= 0) {
    showTemporaryText(`You don't have ${armorTypes[type].name} in your inventory.`);
    return;
  }
  equippedArmor = type;
  applyEquipmentBonuses();
  showTemporaryText(`Equipped ${armorTypes[type].name}`);
}

function equipWeapon(type) {
  if (!weaponTypes[type]) {
    showTemporaryText(`Unknown weapon type: ${type}`);
    return;
  }
  if ((inventory.get(`weapon_${type}`) || 0) <= 0) {
    showTemporaryText(`You don't have ${weaponTypes[type].name} in your inventory.`);
    return;
  }
  equippedWeapon = type;
  applyEquipmentBonuses();
  showTemporaryText(`Equipped ${weaponTypes[type].name}`);
}
  

function useItem(itemName) {
  if ((inventory.get(itemName) || 0) <= 0) return;

  
if (inBattle) {

  const battleAllowed = new Set(['bandaid','emp_grenade','poison_vial','extra_life', 'damage_potion', 'stamina_potion', 'anti_virus', 'driftwood']);
  if (!battleAllowed.has(itemName) && !itemName.startsWith('battle_')) {
    showTemporaryText("You can't use that item during battle.");
    return;
  }
}

  if (itemName === 'bandaid') {
    const healAmount = Math.ceil(playerStats.maxHp * 0.33);
    updateHp(playerStats.currentHp + healAmount);
  } else if (itemName === 'emp_grenade') {
  const STUN_DURATION_MS = 4000;

  activeEnemies.forEach(enemy => {
    if (enemy.resistances && enemy.resistances.stun) return;

  
    enemy.stunned = true;

    if (enemy._stunTimeout != null) {
      clearTimeout(enemy._stunTimeout);
      enemy._stunTimeout = null;
    }


    enemy._stunTimeout = setTimeout(() => {
     
      if (!enemy || enemy.removed || enemy.currentHp == null) {
        if (enemy && enemy._stunTimeout != null) {
          clearTimeout(enemy._stunTimeout);
          enemy._stunTimeout = null;
        }
        if (enemy) enemy.stunned = false;
        drawBattleUI();
        return;
      }

     
      enemy.stunned = false;
      enemy._stunTimeout = null;
      drawBattleUI();
    }, STUN_DURATION_MS);
  });

  drawBattleUI();
  } else if (itemName === 'poison_vial') {
  const POISON_TICK_MS = 500;
  const POISON_DURATION_MS = 3000;
  const poisonDamagePerTick = Math.max(1, Math.ceil(200 * playerStats.damage / 100));

  activeEnemies.forEach(enemy => {
    if (enemy.resistances && enemy.resistances.poison) return;
    enemy.poisoned = true;
    enemy._poisonElapsed = 0;
    enemy._poisonDuration = POISON_DURATION_MS;

    if (enemy._poisonIntervalId != null) {
      enemy._poisonDuration = POISON_DURATION_MS;
      return;
    }

    enemy._poisonIntervalId = setInterval(() => {
      
      if (!enemy || enemy.removed || enemy.currentHp == null) {
        if (enemy && enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        if (enemy) enemy.poisoned = false;
        return;
      }


      enemy.currentHp = Math.max(0, enemy.currentHp - poisonDamagePerTick);
      enemy._poisonElapsed += POISON_TICK_MS;
      enemy._poisonDuration -= POISON_TICK_MS;

      drawBattleUI();

      
      if (enemy.currentHp === 0) {
        const idx = activeEnemies.indexOf(enemy);
        if (enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        enemy.poisoned = false;

        if (idx >= 0) {
          handleEnemyDeath(enemy, idx);
        } else {
          handleEnemyDeath(enemy);
        }
        return;
      }

      if (enemy._poisonDuration <= 0) {
        if (enemy._poisonIntervalId != null) {
          clearInterval(enemy._poisonIntervalId);
          enemy._poisonIntervalId = null;
        }
        enemy.poisoned = false;
      }
    }, POISON_TICK_MS);
  });

  } else if (itemName === 'damage_potion') {
    if (damageBoostTimer) {
      clearTimeout(damageBoostTimer);
    } else {
      playerStats.damage *= 2;
    }
    
    updateStatsPopup();

    damageBoostTimer = setTimeout(() => {
      damageBoostTimer = null;
      applyEquipmentBonuses();
    }, 7000);

    } else if (itemName === 'stamina_potion') {
    updateStamina(playerStats.currentStamina + 100);
    drawPlayerBattleStatus();
    
  } else if (itemName === 'extra_life') {
    if (extraLifeTimerId) {
      clearTimeout(extraLifeTimerId);
      extraLifeTimerId = null;
    }
    
    if (playerStats.currentHp <= 1) {
      playerStats.currentHp = playerStats.maxHp;
      updateHp(playerStats.currentHp);
    }

    extraLifeTimerId = setTimeout(() => {
      extraLifeTimerId = null;
    }, 5000);
  }

  inventory.set(itemName, Math.max(0, (inventory.get(itemName) || 0) - 1));
  drawInventoryBattlePopup();
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
}

function drawBattleUI() {
  const battleOverlay = document.getElementById('battle-overlay');
  battleOverlay.style.display = 'flex';
  const enemyDisplay = document.getElementById('enemy-display');
  enemyDisplay.innerHTML = "";

  const isFogged = playerStats.isFogged;

  activeEnemies.forEach((enemy, index) => {
    const container = document.createElement('div');
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.alignItems = "center";

    const enemyButton = document.createElement('button');
    enemyButton.className = 'enemy-target';

    if (isFogged) {
      enemyButton.innerHTML = `<h3>${enemy.name}</h3><p>HP: ???/???</p>`;
    } else {
      enemyButton.innerHTML = `<h3>${enemy.name}</h3><p>HP: ${enemy.currentHp}/${enemy.maxHp}</p>`;
    }

    if (enemy.shieldActive) enemyButton.classList.add('shielded');
    if (enemy.stunned) enemyButton.classList.add('stunned');
    if (enemy.poisoned) enemyButton.classList.add('poisoned');
    if (enemy.enraged) enemyButton.classList.add('enraged');
    if (enemy.isStoned) enemyButton.classList.add('stoned');
    if (index === selectedEnemyIndex) enemyButton.classList.add('selected');

    enemyButton.dataset.enemyIndex = index;

    const barContainer = document.createElement('div');
    barContainer.className = 'attack-bar-container';

    if (isFogged) {
      barContainer.style.visibility = 'hidden';
    }

    const barFill = document.createElement('div');
    barFill.className = 'attack-bar-fill';
    barFill.id = `attack-bar-${index}`;

    barContainer.appendChild(barFill);
    container.appendChild(enemyButton);
    container.appendChild(barContainer);
    enemyDisplay.appendChild(container);
  });
}

function drawPlayerBattleStatus() {
  const playerBattleStatusDiv = document.getElementById('player-battle-status');
  playerBattleStatusDiv.innerHTML = "";

 function createHeader(entity, defaultName) {
    const container = document.createElement('div');
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.gap = '5px';
    container.style.marginBottom = '4px';

    const nameTxt = document.createElement('p');
    nameTxt.textContent = entity.name || defaultName;
    nameTxt.style.margin = "0";
    container.appendChild(nameTxt);

    const statuses = [
      { active: !!entity._burnType, img: 'burn.png' },
      { active: !!entity.isFrozen, img: 'frozen.png' },
      { active: !!entity.isBlinded, img: 'blinded.png' },
      { active: !!entity.isFogged, img: 'fog.png' },
      { active: !!entity.isBleeding, img: 'bleed.png' },
      { active: !!entity.isWeakened, img: 'weak.png' },
      { active: !!entity.isTargeted, img: 'target.png' }
    ];

    statuses.forEach(s => {
      if (s.active) {
        const icon = document.createElement('img');
        icon.src = s.img;
        icon.style.width = '24px';
        icon.style.height = '24px';
        container.appendChild(icon);
      }
    });
    return container;
  }

  const leftBlock = document.createElement('div');
  leftBlock.style.display = 'inline-block';
  leftBlock.style.verticalAlign = 'top';
  leftBlock.style.marginRight = '12px';

  leftBlock.appendChild(createHeader(playerStats, '8-Bit'));

  const hpContainer = document.createElement('div');
  hpContainer.className = 'hp-bar-container';
  if (playerStats._burnType === 'rocket') hpContainer.classList.add('burn-rocket-hud');
  if (playerStats._burnType === 'mountain') hpContainer.classList.add('burn-mountain-hud');
  hpContainer.style.width = '150px';
  hpContainer.style.height = '15px';
  hpContainer.style.position = 'relative';

  const innerHpBar = document.createElement('div');
  innerHpBar.className = 'hp-bar';
  innerHpBar.style.width = `${(playerStats.currentHp / playerStats.maxHp) * 100}%`;
  innerHpBar.style.height = '100%';
  innerHpBar.style.backgroundColor = '#00FF00';

  const hpTxt = document.createElement('div');
  hpTxt.className = 'hp-text';
  hpTxt.textContent = `${playerStats.currentHp}/${playerStats.maxHp}`;

  hpContainer.appendChild(innerHpBar);
  hpContainer.appendChild(hpTxt);
  leftBlock.appendChild(hpContainer);

  const rightBlock = document.createElement('div');
  rightBlock.style.display = 'inline-block';
  rightBlock.style.verticalAlign = 'top';

  if (activeAlly) {
    rightBlock.appendChild(createHeader(activeAlly, 'Ally'));

    const allyHpContainer = document.createElement('div');
    allyHpContainer.className = 'hp-bar-container';
    if (activeAlly._burnType === 'rocket') allyHpContainer.classList.add('burn-rocket-hud');
    if (activeAlly._burnType === 'mountain') allyHpContainer.classList.add('burn-mountain-hud');
    allyHpContainer.style.width = '120px';
    allyHpContainer.style.height = '15px';
    allyHpContainer.style.position = 'relative';

    const allyInner = document.createElement('div');
    allyInner.className = 'hp-bar';
    const allyPercent = (activeAlly.currentHp / activeAlly.maxHp) * 100 || 0;
    allyInner.style.width = `${allyPercent}%`;
    allyInner.style.height = '100%';
    allyInner.style.backgroundColor = '#00FF00';

    const allyHpText = document.createElement('div');
    allyHpText.className = 'hp-text';
    allyHpText.textContent = `${activeAlly.currentHp}/${activeAlly.maxHp}`;

    allyHpContainer.appendChild(allyInner);
    allyHpContainer.appendChild(allyHpText);
    rightBlock.appendChild(allyHpContainer);
  } else {
    rightBlock.innerHTML = '<p style="opacity:0.7">No ally equipped</p>';
  }


  playerBattleStatusDiv.appendChild(leftBlock);
  playerBattleStatusDiv.appendChild(rightBlock);

 
  const staminaContainer = document.createElement('div');
  staminaContainer.className = 'hp-bar-container';
  staminaContainer.style.marginTop = '8px';
  staminaContainer.style.width = '100%';
  staminaContainer.style.height = '12px';
  staminaContainer.style.position = 'relative';

  const staminaBar = document.createElement('div');
  staminaBar.className = 'hp-bar';
  staminaBar.style.width = `${(playerStats.currentStamina / playerStats.maxStamina) * 100}%`;
  staminaBar.style.height = '100%';
  staminaBar.style.backgroundColor = '#00FFFF'; 

  const staminaText = document.createElement('div');
  staminaText.className = 'hp-text';
  staminaText.textContent = `${playerStats.currentStamina}/${playerStats.maxStamina}`;

  staminaContainer.appendChild(staminaBar);
  staminaContainer.appendChild(staminaText);
  playerBattleStatusDiv.appendChild(staminaContainer);

  if (activeAlly) {
    const targetDiv = document.createElement('div');
    targetDiv.style.marginTop = "10px";
    targetDiv.style.display = "flex";
    targetDiv.style.gap = "5px";
    targetDiv.style.justifyContent = "center";

    const modes = ['Current', 'First', 'Weakest', 'Strongest'];
    modes.forEach(mode => {
      const btn = document.createElement('button');
      btn.textContent = mode;
      btn.className = 'item-use-button';
      btn.style.fontSize = "9px";
      btn.style.padding = "4px";
      
      if (allyTargetMode === mode) {
        btn.style.border = "2px solid yellow";
        btn.style.backgroundColor = "#555";
      }

      btn.onclick = () => {
        allyTargetMode = mode;
        drawPlayerBattleStatus();
      };
      targetDiv.appendChild(btn);
    });
    playerBattleStatusDiv.appendChild(targetDiv);
  }  
}



  function drawPartyStatus() {
  const partyHud = document.getElementById('party');
  if (!partyHud) return;

  let statusDiv = partyHud.querySelector('.party-status');
  if (!statusDiv) {
    statusDiv = document.createElement('div');
    statusDiv.className = 'party-status';
    statusDiv.style.marginTop = '10px';
    partyHud.appendChild(statusDiv);
  }
  statusDiv.innerHTML = '';

  if (!activeAlly) {
    statusDiv.textContent = ' ';
    return;
  }

  const nameP = document.createElement('p');
  nameP.textContent = `${activeAlly.name} (Lvl ${activeAlly.level})`;
  nameP.style.fontWeight = 'bold';
  statusDiv.appendChild(nameP);

  const hpContainer = document.createElement('div');
  hpContainer.className = 'hp-bar-container';
  hpContainer.style.width = '150px';
  hpContainer.style.height = '15px';
  hpContainer.style.backgroundColor = '#555';
  hpContainer.style.border = '1px solid white';
  hpContainer.style.position = 'relative';

  const hpBar = document.createElement('div');
  hpBar.className = 'hp-bar';
  const hpPercent = (activeAlly.currentHp / activeAlly.maxHp) * 100;
  hpBar.style.width = `${hpPercent}%`;
  hpBar.style.height = '100%';
  hpBar.style.backgroundColor = '#00FF00';

  const hpText = document.createElement('div');
  hpText.className = 'hp-text';
  hpText.textContent = `${activeAlly.currentHp} / ${activeAlly.maxHp}`;
  hpText.style.position = 'absolute';
  hpText.style.top = '50%';
  hpText.style.left = '50%';
  hpText.style.transform = 'translate(-50%, -50%)';
  hpText.style.fontSize = '0.7em';
  hpText.style.textShadow = '1px 1px 2px black';
  hpText.style.userSelect = 'none';

  hpContainer.appendChild(hpBar);
  hpContainer.appendChild(hpText);
  statusDiv.appendChild(hpContainer);
}
  function startAllyAttacking() {
  if (!activeAlly) return;
  if (activeAlly.attackTimerId) clearInterval(activeAlly.attackTimerId);

  activeAlly.attackTimerId = setInterval(() => {
    if (!inBattle || !activeAlly || activeAlly.currentHp <= 0) {
      clearInterval(activeAlly.attackTimerId);
      return;
    }
    if (!activeEnemies.length) return;
    let targetEnemy = null;

  if (activeAlly.isBlinded && Math.random() < 0.5) {
      return;
    }

    if (allyTargetMode === 'Current') {
      targetEnemy = activeEnemies[selectedEnemyIndex] || activeEnemies[0];
    } 
    else if (allyTargetMode === 'First') {
      targetEnemy = activeEnemies[0];
    } 
    else if (allyTargetMode === 'Weakest') {
      targetEnemy = activeEnemies.reduce((prev, curr) => 
        (curr.currentHp < prev.currentHp) ? curr : prev
      );
    } 
    else if (allyTargetMode === 'Strongest') {
      targetEnemy = activeEnemies.reduce((prev, curr) => 
        (curr.currentHp > prev.currentHp) ? curr : prev
      );
    }

    if (!targetEnemy) return;

  if (targetEnemy.isStoned) {
    return;
  }

    if (targetEnemy.shieldActive) {
      showTemporaryText(`${activeAlly.name}'s attack was blocked by shield!`);
    } else {
      targetEnemy.currentHp -= activeAlly.damage;

      const enemyIdx = activeEnemies.indexOf(targetEnemy);
      spawnDamageNumber(enemyIdx, activeAlly.damage);

      if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;
      showTemporaryText(`${activeAlly.name} attacks ${targetEnemy.name} for ${activeAlly.damage} damage!`);
    }

    if (targetEnemy.currentHp === 0) {
      handleEnemyDeath(targetEnemy);

      if (selectedEnemyIndex >= activeEnemies.length) {
        selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
      }

      drawBattleUI();
      drawPlayerBattleStatus();
      drawPartyStatus();

      if (activeEnemies.length === 0) {
        endBattle('win');
      }
    } else {
      drawBattleUI();
    }
  }, activeAlly.attackIntervalMs);
}

  function applyStatusEffect(target, status, duration) {
  const statusMap = {
    'blind': 'isBlinded',
    'frozen': 'isFrozen',
    'fog': 'isFogged',
    'weaken': 'isWeakened'
  };
  
  const flag = statusMap[status];
  if (!flag) return;
  target[flag] = true;
  drawPlayerBattleStatus();

  if (target[flag + 'Timeout']) clearTimeout(target[flag + 'Timeout']);

  target[flag + 'Timeout'] = setTimeout(() => {
    target[flag] = false;
    showTemporaryText(`${target.name || '8-Bit'} recovered from ${status}!`);
    drawPlayerBattleStatus();
    if (status === 'fog') drawBattleUI(); 
  }, duration);
}

// Enemy behaviors
// normal enemy attack
function normalAttack(enemy, target) {
  const damage = enemy.damage || 0;
   if (typeof normalAttack === 'function') {
    const _orig_normalAttack = normalAttack;
    normalAttack = function(enemy, target) {
      if (target === playerStats) {
        const dmg = enemy.damage || 0;
        if (typeof playerTakeDamage === 'function') playerTakeDamage(dmg, enemy);
        else _orig_normalAttack(enemy, target);
      } else {
        _orig_normalAttack(enemy, target);
      }
    };
  }
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} attacks you for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} attacks ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

function sniperAttack(enemy, target) {
  if (typeof sniperAttack === 'function') {
    const _orig_sniperAttack = sniperAttack;
    sniperAttack = function(enemy, target) {
      const isCritical = Math.random() < 0.3;
      const damage = isCritical ? (enemy.damage * 3) : enemy.damage;
      if (target === playerStats) {
        if (typeof playerTakeDamage === 'function') playerTakeDamage(damage, enemy);
        else _orig_sniperAttack(enemy, target);
      } else {
        _orig_sniperAttack(enemy, target);
      }
    };
  }
  const isCritical = Math.random() < 0.3;
  const damage = isCritical ? (enemy.damage * 3) : enemy.damage;
  if (target === playerStats) {
    playerTakeDamage(damage);
    showTemporaryText(`${enemy.name} ${isCritical ? 'snipes critically' : 'attacks'} for ${damage} damage!`);
  } else if (target === activeAlly) {
    activeAlly.currentHp -= damage;
    if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
    showTemporaryText(`${enemy.name} ${isCritical ? 'snipes critically' : 'attacks'} ${activeAlly.name} for ${damage} damage!`);
    if (activeAlly.currentHp === 0) {
      showTemporaryText(`${activeAlly.name} has been defeated!`);
      clearInterval(activeAlly.attackTimerId);
      activeAlly.attackTimerId = null;
    }
  }
}

function bossBehavior(enemy, target) {
  const now = Date.now();
  if (!enemy.shieldActivatedAt) enemy.shieldActivatedAt = 0;
  if (!enemy.shieldCooldownEnd) enemy.shieldCooldownEnd = 0;

  if (enemy.rocketActive && enemy.rocketTicksLeft > 0) {
    const burnTarget = (target === playerStats) ? playerStats : activeAlly;
    if (burnTarget && !burnTarget._rocketTimerRunning) {
      showTemporaryText(`${enemy.name}'s rocket hits ${burnTarget.name || '8-Bit'}!`);
      burnTarget._burnType = 'rocket';
      burnTarget._rocketTimerRunning = true;
      let burnTicks = 0;
      const rId = setInterval(() => {
        burnTicks++;
        if (!inBattle || burnTicks > 4 || !burnTarget._burnType) {
          clearInterval(rId);
          burnTarget._burnType = null;
          burnTarget._rocketTimerRunning = false;
          drawPlayerBattleStatus();
          return;
        }
        const tickDmg = Math.max(2, Math.floor(playerStats.maxHp * 0.05));
        if (burnTarget === playerStats) playerTakeDamage(tickDmg);
        else burnTarget.currentHp = Math.max(0, burnTarget.currentHp - tickDmg);
        drawPlayerBattleStatus();
      }, 800);
    }
    enemy.rocketActive = false;
  }

  if (!enemy.rocketActive && Math.random() < 0.25) {
    enemy.rocketActive = true;
    enemy.rocketTicksLeft = 1; 
    showTemporaryText(`${enemy.name} locks on with a rocket!`);
  }

  if (enemy.shieldActive) {
    if (now >= enemy.shieldActivatedAt + 2000) {
      enemy.shieldActive = false;
      enemy.shieldCooldownEnd = now + 4000;
    }
    return; 
  } else {
    if (now >= enemy.shieldCooldownEnd) {
      enemy.shieldActive = true;
      enemy.shieldActivatedAt = now;
      return;
    }
  }

  normalAttack(enemy, target);
}


function summonerBehavior(enemy, target) {
  if (!enemy.lastSummonTime) enemy.lastSummonTime = 0;
  const now = Date.now();

  if (now - enemy.lastSummonTime >= 4000) {
    enemy.lastSummonTime = now;

    const minionBase = enemyTypes["Botling"];
    const minionStats = scaleEnemyStats(minionBase);
    const minion = {
      type: "Botling",
      name: minionStats.name,
      maxHp: minionStats.maxHp,
      currentHp: minionStats.maxHp,
      damage: minionStats.damage,
      xpReward: minionStats.xpReward,
      shieldActive: false,
      shieldCooldownEnd: 0,
      rocketActive: false,
      rocketTicksLeft: 0,
      stunned: false,
      poisoned: false
    };

    activeEnemies.push(minion);
    showTemporaryText(`${enemy.name} summons a minion!`);
    drawBattleUI();
  }

  if (!enemy.stunned) {
    normalAttack(enemy, target);
  }
}

function secondStageBossBehavior(enemy, target) {
  if (!enemy.stunned) {
    normalAttack(enemy, target);
  }
}

  function sandBehavior(enemy, target) {
  const now = Date.now();
  if (!enemy._lastBlindAt) enemy._lastBlindAt = 0;

  if (now - enemy._lastBlindAt >= 10000) {
    enemy._lastBlindAt = now;
 
    applyStatusEffect(playerStats, 'blind', 5000); 

    if (activeAlly) applyStatusEffect(activeAlly, 'blind', 5000);
  }

  normalAttack(enemy, target);
}

  // snowtel boss
function iceBossBehavior(enemy, target) {
  const now = Date.now();

  if (!enemy.lastFreezeTime) enemy.lastFreezeTime = 0;

  if (enemy.shieldActive) {
    return;
  }
  if (now - enemy.lastFreezeTime >= 8000) {
    enemy.lastFreezeTime = now;

    playerStats.isFrozen = true;
    if (activeAlly) activeAlly.isFrozen = true;
    drawPlayerBattleStatus();

    const attackButton = document.getElementById('attack-button');
    const specialButton1 = document.getElementById('special-attack-button-1');
    const specialButton2 = document.getElementById('special-attack-button-2');
    const inventoryBattleButton = document.getElementById('inventory-battle-button');

    if (attackButton) attackButton.disabled = true;
    if (specialButton1) specialButton1.disabled = true;
    if (specialButton2) specialButton2.disabled = true;
    if (inventoryBattleButton) inventoryBattleButton.disabled = true;

    if (activeAlly) {
      activeAlly.stunned = true;
    }

    setTimeout(() => {
      if (attackButton) attackButton.disabled = false;
      if (specialButton1) specialButton1.disabled = false;
      if (specialButton2) specialButton2.disabled = false;
      if (inventoryBattleButton) inventoryBattleButton.disabled = false;

      playerStats.isFrozen = false;
      if (activeAlly) {
        activeAlly.stunned = false;
        activeAlly.isFrozen = false;
      }
      drawPlayerBattleStatus();
    }, 3000);

    return;
  }
  if (!enemy.stunned) {
    normalAttack(enemy, target);
  }
}

function swordBehavior(enemy, target) {
  if (enemy.stunned) return;

  const now = Date.now();

  if (Math.random() < 0.4 && !enemy.isTelegraphing) {
    enemy.isTelegraphing = true;
    

    const enemyButtons = document.querySelectorAll('.enemy-target');
    const enemyIdx = activeEnemies.indexOf(enemy);
    const targetBtn = Array.from(enemyButtons).find(b => parseInt(b.dataset.enemyIndex) === enemyIdx);
    
    let mark = null;
    if (targetBtn) {
      mark = document.createElement('div');
      mark.className = 'telegraph-mark';
      mark.textContent = '!';
      targetBtn.style.position = 'relative';
      targetBtn.appendChild(mark);
    }

    setTimeout(() => {
      if (!inBattle || enemy.currentHp <= 0) {
        if (mark) mark.remove();
        return;
      }
      
      if (mark) mark.remove();
      enemy.isTelegraphing = false;

      const hud = document.getElementById('player-battle-status');
      const rect = hud.getBoundingClientRect();
      const slash = document.createElement('div');
      slash.className = 'sword-trail';
      slash.style.left = rect.left + 'px';
      slash.style.top = (rect.top + 20) + 'px';
      document.body.appendChild(slash);
      setTimeout(() => slash.remove(), 400);
      const bleedTarget = (target === playerStats) ? playerStats : activeAlly;
      if (bleedTarget) {
        bleedTarget.isBleeding = true;
        showTemporaryText(`${enemy.name} applied BLEED to ${bleedTarget.name || '8-Bit'}!`);
        
        setTimeout(() => {
          bleedTarget.isBleeding = false;
          drawPlayerBattleStatus();
        }, 6000);
      }
      
      drawPlayerBattleStatus();
    }, 1000);

  } else if (!enemy.isTelegraphing) {
    normalAttack(enemy, target);
  }
}

//mortuary boss
function lifeStealBossBehavior(enemy, target) {
  if (enemy.shieldActive) {
    return;
  }

  if (!enemy.stunned) {
    const damage = enemy.damage || 0;
    if (target === playerStats) {
      playerTakeDamage(damage);
      showTemporaryText(`${enemy.name} life steals you for ${damage} damage!`);
    } else if (target === activeAlly) {
      activeAlly.currentHp -= damage;
      if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
      showTemporaryText(`${enemy.name} life steals ${activeAlly.name} for ${damage} damage!`);
      if (activeAlly.currentHp === 0) {
        showTemporaryText(`${activeAlly.name} has been defeated!`);
        clearInterval(activeAlly.attackTimerId);
        activeAlly.attackTimerId = null;
      }
    }

    enemy.currentHp += damage;
    if (enemy.currentHp > enemy.maxHp) enemy.currentHp = enemy.maxHp;
    showTemporaryText(`${enemy.name} heals for ${damage} HP!`);

    drawBattleUI();
    drawPlayerBattleStatus();
  }
}
// Cave boss 
function caveBossBehavior(enemy, target) {
  if (!enemy._shardIntervalId) {
    enemy._shardIntervalId = setInterval(() => {
      if (!inBattle) return;
      const shardBase = enemyTypes['CrystalShard'];
      const mult = getDifficultyMultipliers();
      const shard = {
        type: 'CrystalShard',
        name: shardBase.name,
        maxHp: Math.max(1, Math.floor(shardBase.maxHp * mult.enemyHp)),
        currentHp: Math.max(1, Math.floor(shardBase.maxHp * mult.enemyHp)),
        damage: Math.max(0, Math.floor(shardBase.damage * mult.enemyDmg)),
        xpReward: shardBase.xpReward || 0,
        shieldActive: false,
        shieldCooldownEnd: 0,
        rocketActive: false,
        rocketTicksLeft: 0,
        stunned: false,
        poisoned: false,
        resistances: shardBase.defaultResistances || {}
      };
      activeEnemies.push(shard);
      drawBattleUI();
      showTemporaryText('A Crystal Shard appears!');
    }, 1500);
  }

  const hpPercent = (enemy.currentHp / enemy.maxHp) * 100;
  if (hpPercent <= 50) {
    if (!enemy._blackoutRunning) {
      enemy._blackoutRunning = true;

      enemy._blackoutIntervalId = setInterval(() => {
        showBattleBlackout();
        setTimeout(() => {
          hideBattleBlackout();
        }, 9000);
      }, 10000);

      showBattleBlackout();
      setTimeout(() => {
        hideBattleBlackout();
      }, 9000);
    }
  }

  if (!enemy.stunned) {
    const dmg = enemy.damage || 0;
    if (target === playerStats) {
      playerTakeDamage(dmg);
    } else if (target === activeAlly && activeAlly) {
      activeAlly.currentHp -= dmg;
      if (activeAlly.currentHp < 0) activeAlly.currentHp = 0;
      if (activeAlly.currentHp === 0) {
        showTemporaryText(`${activeAlly.name} has been defeated!`);
        clearInterval(activeAlly.attackTimerId);
        activeAlly.attackTimerId = null;
      }
    }
  }
}

//battlefield boss
function critBossBehavior(enemy, target) {
  if (enemy.stunned || enemy.isStoned) return;

  const hpPercent = (enemy.currentHp / enemy.maxHp) * 100;

  if (hpPercent <= 25) {
    if (!enemy._phase3Triggered) {
      enemy._phase3Triggered = true;
      showBattleDialog([{ speaker: enemy.name, text: "8-Bit, please, my systems are losing power...", style: 'unit' }]);
      
      enemy._drainInterval = setInterval(() => {
        if (!inBattle || enemy.currentHp <= 1) {
          clearInterval(enemy._drainInterval);
          return;
        }
        enemy.currentHp -= 1;
        drawBattleUI();
      }, 1000);
    }
    normalAttack(enemy, target);
    return;
  }

  if (hpPercent <= 50) {
    if (!enemy._phase2Triggered) {
      enemy._phase2Triggered = true;
      showBattleDialog([{ speaker: enemy.name, text: "I think I'm regaining myself...", style: 'unit' }]);

      playerStats.isTargeted = false;
      if (activeAlly) activeAlly.isTargeted = false;
      drawPlayerBattleStatus();
    }
    normalAttack(enemy, target);
    return;
  }

  const targetedEntity = (playerStats.isTargeted) ? playerStats : (activeAlly && activeAlly.isTargeted ? activeAlly : null);

  if (targetedEntity) {
    const dmg = enemy.damage * 3;
    if (targetedEntity === playerStats) {
      playerTakeDamage(dmg, enemy);
    } else {
      targetedEntity.currentHp = Math.max(0, targetedEntity.currentHp - dmg);
    }
    
    targetedEntity.isTargeted = false;
    drawPlayerBattleStatus();
  } else {
    if (Math.random() < 0.30) {
      const luckyWinner = (activeAlly && activeAlly.currentHp > 0 && Math.random() < 0.5) ? activeAlly : playerStats;
      luckyWinner.isTargeted = true;
      drawPlayerBattleStatus();
    } else {
      normalAttack(enemy, target);
    }
  }
}


function smokeBehavior(enemy, target) {
    const now = Date.now();
    if (!enemy._lastFogAt) enemy._lastFogAt = 0;

    if (now - enemy._lastFogAt >= 10000) {
        enemy._lastFogAt = now;
        applyStatusEffect(playerStats, 'fog', 5000);
        if (activeAlly) applyStatusEffect(activeAlly, 'fog', 5000);
    }
    normalAttack(enemy, target);
}

// Healer
function healerBehavior(enemy) {
  if (!enemy.lastHealTime) enemy.lastHealTime = 0;
  const now = Date.now();

  if (now - enemy.lastHealTime >= 3000) {
    enemy.lastHealTime = now;

    activeEnemies.forEach(ally => {
      if (ally.currentHp < ally.maxHp) {
        const healAmount = Math.floor(ally.maxHp * 0.15);
        ally.currentHp += healAmount;
        if (ally.currentHp > ally.maxHp) ally.currentHp = ally.maxHp;
      }
    });
    showTemporaryText(`${enemy.name} heals all allies!`);
    drawBattleUI();
  }

  if (!enemy.stunned) {
    normalAttack(enemy);
  }
}

  const MOUNTAIN_PEN_CONFIG = {
  penRespawnIntervalMs: 10000,   // spawn a pen every 10s (if none present)
  sheepSummonIntervalMs: 3000,   // each pen summons a sheep every 3s (or choose a value)
  sheepLifetimeMs: 3000,         // sheep exist for 3s then are "eaten"
  sheepHealPercent: 0.05         // heal boss for 5% of its maxHp when a sheep is eaten
};

  function toggleAutofire(on) {
  const btn = document.getElementById('attack-button');
  if (on) {
    btn.disabled = true;
    clickingInterval = setInterval(() => {
        if (inBattle && !isGameOver) performPlayerAttack();
        else toggleAutofire(false);
    }, 200);
  } else {
    btn.disabled = false;
    clearInterval(clickingInterval);
    clickingInterval = null;
    activeAmulets.clicking = false;
  }
}

  
(function ensureAbilityButtons() {
  const controls = document.getElementById('battle-controls');
  if (!controls) return;

  function makeBtn(id, text) {
    if (document.getElementById(id)) return document.getElementById(id);
    const btn = document.createElement('button');
    btn.id = id;
    btn.className = 'ability-button';
    btn.style.position = 'relative';
    btn.style.overflow = 'hidden';
    btn.style.minWidth = '90px';
    btn.style.fontSize = '10px';
    btn.textContent = text;
    const overlay = document.createElement('div');
    overlay.className = id + '-overlay';
    overlay.style.position = 'absolute';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.background = 'rgba(0,0,0,0.6)';
    overlay.style.display = 'none';
    overlay.style.pointerEvents = 'none';
    overlay.style.transition = 'width 0.2s linear';
    overlay.style.zIndex = '100';
    btn.appendChild(overlay);
    controls.insertBefore(btn, controls.querySelector('#inventory-battle-button'));
    return btn;
  }

  makeBtn('ability-block', 'Block');
  makeBtn('ability-counter', 'Counter');
  makeBtn('ability-cleanse', 'Cleanse');
})();

function updateAbilityButtonsUI() {
  const isFrozen = playerStats.isFrozen;

  ['block','counter','cleanse'].forEach(name => {
    const btn = document.getElementById(`ability-${name}`);
    if (!btn) return;
    const overlay = btn.querySelector(`.${btn.id}-overlay`);
    const cd = abilityCooldowns[name] || 0;

    if (isFrozen) {
      btn.disabled = true;
      btn.style.opacity = '0.3'; 
      if (overlay) overlay.style.display = 'none';
      return;
    }

    if (cd <= 0) {
      btn.disabled = false;
      if (overlay) overlay.style.display = 'none';
      btn.style.opacity = '1';
    } else {
      btn.disabled = true;
      if (overlay) {
        overlay.style.display = 'block';
        const frac = Math.max(0, Math.min(1, cd / ABILITIES[name].cooldownMs));
        overlay.style.width = `${frac * 100}%`;
      }
      btn.style.opacity = '0.6';
    }
  });

  const blockBtn = document.getElementById('ability-block');
  if (blockBtn) blockBtn.style.boxShadow = blockActive ? '0 0 10px 3px rgba(0,200,255,0.7)' : '';
  const counterBtn = document.getElementById('ability-counter');
  if (counterBtn) counterBtn.style.boxShadow = counterWindowActive ? '0 0 10px 3px rgba(255,200,0,0.7)' : '';
}

function startAbilityRegen() {
  if (abilityRegenIntervalId) clearInterval(abilityRegenIntervalId);
  abilityRegenIntervalId = setInterval(() => {
    let changed = false;
    let tickReduction = 200;
    if (activeAmulets.defense) tickReduction += 200;

    ['block','counter','cleanse'].forEach(name => {
      if (abilityCooldowns[name] > 0) {
        abilityCooldowns[name] = Math.max(0, abilityCooldowns[name] - tickReduction);
        changed = true;
      } else {
        abilityCooldowns[name] = 0;
      }
    });

    if (changed) updateAbilityButtonsUI();
  }, 200);
}


function stopAbilityRegen() {
  if (abilityRegenIntervalId) {
    clearInterval(abilityRegenIntervalId);
    abilityRegenIntervalId = null;
  }
}

  function resetAbilitiesForBattle() {
  abilityCooldowns.block = 0;
  abilityCooldowns.counter = 0;
  abilityCooldowns.cleanse = 0;
  blockActive = false;
  counterWindowActive = false;
  updateAbilityButtonsUI();
  startAbilityRegen();
}
  function pauseBattleTimersForDialog() {
  _battleDialogPausedState = {
    enemyAttackIntervalId,
    staminaRegenIntervalId,
    abilityRegenIntervalId,
    allyAttackTimerId: activeAlly && activeAlly.attackTimerId ? activeAlly.attackTimerId : null
  };
  
activeEnemies.forEach(e => {
    if (e.attackTimerId) clearInterval(e.attackTimerId);
  });
  if (enemyAttackIntervalId) { clearInterval(enemyAttackIntervalId); enemyAttackIntervalId = null; }
  if (staminaRegenIntervalId) { clearInterval(staminaRegenIntervalId); staminaRegenIntervalId = null; }
  if (abilityRegenIntervalId) { clearInterval(abilityRegenIntervalId); abilityRegenIntervalId = null; }
  if (activeAlly && activeAlly.attackTimerId) { clearInterval(activeAlly.attackTimerId); activeAlly.attackTimerId = null; }



  const attackBtn = document.getElementById('attack-button');
  const sp1 = document.getElementById('special-attack-button-1');
  const sp2 = document.getElementById('special-attack-button-2');
  const invBtn = document.getElementById('inventory-battle-button');
  if (attackBtn) attackBtn.disabled = true;
  if (sp1) sp1.disabled = true;
  if (sp2) sp2.disabled = true;
  if (invBtn) invBtn.disabled = true;
}

function resumeBattleTimersAfterDialog() {
  if (!inBattle) return;
  if (!_battleDialogPausedState) return;

  const now = Date.now();

  activeEnemies.forEach(e => {
    e.lastAttackAt = now; 
    e.attackTimerId = setInterval(() => performEnemyAction(e), e.attackSpeed);
  });

  if (!staminaRegenIntervalId) {
    staminaRegenIntervalId = setInterval(() => { 
      updateStamina(playerStats.currentStamina + 1); 
      drawPlayerBattleStatus(); 
    }, 100);
  }

  if (!abilityRegenIntervalId) startAbilityRegen();
  
  if (_battleDialogPausedState.allyAttackTimerId && activeAlly && !activeAlly.attackTimerId) {
    startAllyAttacking();
  }
  const attackBtn = document.getElementById('attack-button');
  const sp1 = document.getElementById('special-attack-button-1');
  const sp2 = document.getElementById('special-attack-button-2');
  const invBtn = document.getElementById('inventory-battle-button');
  
  if (attackBtn) attackBtn.disabled = false;
  if (sp1) sp1.disabled = false;
  if (sp2) sp2.disabled = false;
  if (invBtn) invBtn.disabled = false;

  _battleDialogPausedState = null;
}

  
  function passiveArmorHeal() {
  if (equippedArmor && armorTypes[equippedArmor] && armorTypes[equippedArmor].passiveHealPercent) {
    if (playerStats.currentHp < playerStats.maxHp) {
      const healAmount = Math.ceil(playerStats.maxHp * armorTypes[equippedArmor].passiveHealPercent);
      playerStats.currentHp = Math.min(playerStats.currentHp + healAmount, playerStats.maxHp);
      
      updateHp(playerStats.currentHp);
      showTemporaryText(`Armor Heal: +${healAmount} HP`);
    }
  }
}
  function playerTakeDamage(amount, attacker) {
  if (equippedArmor === "haunted") {
    const blockChance = armorTypes["haunted"].blockChance || 0;
    if (Math.random() < blockChance) {
      return;
    }
  }

  if (blockActive) {
    if (playerStats.isTargeted) {
  } else {
    return;
  }
}

  if (counterWindowActive) {
    const targetToHit = attacker || activeEnemies[selectedEnemyIndex];
    if (targetToHit) {
      targetToHit.currentHp = Math.max(0, targetToHit.currentHp - (amount * 3));
      spawnDamageNumber(activeEnemies.indexOf(targetToHit), amount * 3);
      if (targetToHit.currentHp <= 0) {
        targetToHit.currentHp === 1;
      }
    }
    return;
  }

  playerStats.currentHp -= amount;

  const hurtSound = new Audio('hitHurt.wav');
  hurtSound.play().catch(e=>{});

  if (!canGoBelow1Hp() && playerStats.currentHp <= 0) {
    playerStats.currentHp = playerStats.maxHp;
  }

  if (playerStats.currentHp < 0) playerStats.currentHp = 0;

  updateHp(playerStats.currentHp);

  if (playerStats.currentHp <= 0) {
    endBattle('lose');
  }
}

  function handleEnemyDeath(enemy) {
    const deathSound = new Audio('enemydie.wav');
deathSound.play();

    if (enemy && enemy.attackTimerId) {
    clearInterval(enemy.attackTimerId);
    enemy.attackTimerId = null;
  }
    
    const enemyButtons = document.querySelectorAll('.enemy-target');
  const enemyIdx = activeEnemies.indexOf(enemy);
  const targetBtn = Array.from(enemyButtons).find(b => parseInt(b.dataset.enemyIndex) === enemyIdx);

if (enemy._shardIntervalId) { clearInterval(enemy._shardIntervalId); enemy._shardIntervalId = null; }
if (enemy._blackoutIntervalId) { clearInterval(enemy._blackoutIntervalId); enemy._blackoutIntervalId = null; }
enemy._blackoutRunning = false;
enemy._isBlackout = false;


const willHideBattleBlackout = (() => {
  
  const others = activeEnemies.filter(e => e && e !== enemy);
  return !others.some(e => e && (e._blackoutIntervalId || e._blackoutRunning || e._isBlackout));
})();
if (willHideBattleBlackout) {
  hideBattleBlackout();
}
  if (enemy && enemy.xpReward) gainXP(enemy.xpReward);

  if (enemy.behaviorTimers && enemy.behaviorTimers.length) {
    enemy.behaviorTimers.forEach(id => clearInterval(id));
    enemy.behaviorTimers = [];
  }

  const idx = activeEnemies.indexOf(enemy);
  if (idx > -1) activeEnemies.splice(idx, 1);

  const DROP_CHANCE = 0.30;
//bolts
  const boltDroppers = new Set([
    'Sniperbot',
    'Puncherbot',
    'Partybot',
    'Mousebot',
    'Drunkard',
    'Partyguard',
    'Partyblocker',
    'Partygoers',
    'Attictank',
    'Atticsniper'
  ]);

  let bonusBolts = 0;
  if (equippedGears.includes('magnet_gear')) bonusBolts = 1;

  if (boltDroppers.has(enemy.type) && Math.random() < DROP_CHANCE) {
    const currentBolts = inventory.get('bolts') || 0;
    inventory.set('bolts', currentBolts + 1 + bonusBolts);
  }
//gears
  const normalGearDroppers = new Set([
    'Sniperbot',
    'Puncherbot',
    'Partybot',
    'Mousebot',
    'Drunkard'
  ]);
    
  if (normalGearDroppers.has(enemy.type) && Math.random() < 0.03) {
    const currentDmgI = inventory.get('gear_dmg_gear_1') || 0;
    inventory.set('gear_dmg_gear_1', currentDmgI + 1);
  }
    if (normalGearDroppers.has(enemy.type) && Math.random() < 0.03) {
    const currentHpI = inventory.get('gear_hp_gear_1') || 0;
    inventory.set('gear_hp_gear_1', currentHpI + 1);
  }
  
   if (equippedGears.includes('vampire_gear')) {
  let healedHp = playerStats.currentHp + 0.1 * playerStats.maxHp;
  healedHp = Math.min(playerStats.maxHp, Math.max(0, healedHp));
  healedHp = Math.round(healedHp);
  playerStats.currentHp = healedHp;
  updateHp(playerStats.currentHp);
}

  
  achievementsMap['kill_enemies'].progress++;
  achievementsMap['kill_enemies2'].progress++;
  achievementsMap['kill_enemies3'].progress++;
  if (enemy.type === 'Dummy') achievementsMap['kill_tutorial_dummy'].progress = 1;
  checkAchievements();

  if (enemy._stunTimeout) {
    clearTimeout(enemy._stunTimeout);
    enemy._stunTimeout = null;
  }
  if (enemy._poisonIntervalId) {
    clearInterval(enemy._poisonIntervalId);
    enemy._poisonIntervalId = null;
  }
  enemy.stunned = false;
  enemy.poisoned = false;

  if (activeEnemies.length === 0) {
    endBattle('win');
  } else {
    drawBattleUI();
    drawPlayerBattleStatus();
    drawPartyStatus();
  }
}
    
function healAllyAfterBattle() {
  if (activeAlly && activeAlly.currentHp > 0) {
    const healAmount = Math.ceil(activeAlly.maxHp * 0.33);
    activeAlly.currentHp = Math.min(activeAlly.currentHp + healAmount, activeAlly.maxHp);
  }
}

function showVictorySequence(onComplete) {
  const overlay = document.getElementById('battle-overlay');
  const banner = document.createElement('div');
  banner.id = 'victory-banner';
  
 
  const word = "VICTORY!";
  word.split('').forEach((char, i) => {
    const span = document.createElement('span');
    span.textContent = char;
    span.className = 'victory-letter';
    span.style.animationDelay = (i * 0.1) + 's'; 
    banner.appendChild(span);
  });

  document.body.appendChild(banner);

  const victoryJingle = new Audio('victory.wav');
  victoryJingle.play().catch(e => console.log("Audio play blocked"));

  setTimeout(() => {
    banner.remove();
    overlay.classList.add('fade-out');
    
    setTimeout(() => {
      overlay.classList.remove('fade-out');
      onComplete();
    }, 700);
  }, 1000);
}

  
function endBattle(outcome) {

  if (outcome === 'win') {
    battleRounds--;
    if (battleRounds > 0) {
      currentRoundIndex++;
      spawnRound(currentRoundIndex);
      draw();
      return;
    }
  }
  
  inBattle = false;

  const overlay = document.getElementById('battle-overlay');
  if (overlay) overlay.style.display = 'none';

  const entities = [playerStats, activeAlly];
  entities.forEach(ent => {
    if (!ent) return;

    ent._burnType = null;
    ent.isFrozen = false;
    ent.isBlinded = false;
    ent.isFogged = false;
    ent.isWeakened = false;

    if (ent.isBlindedTimeout) clearTimeout(ent.isBlindedTimeout);
    if (ent.isFrozenTimeout) clearTimeout(ent.isFrozenTimeout);
    if (ent.isFoggedTimeout) clearTimeout(ent.isFoggedTimeout);
    if (ent.isWeakenedTimeout) clearTimeout(ent.isWeakenedTimeout);
  });

  drawPlayerBattleStatus();

  if (staminaRegenIntervalId) {
    clearInterval(staminaRegenIntervalId);
    staminaRegenIntervalId = null;
  }

  if (enemyAttackIntervalId) {
    clearInterval(enemyAttackIntervalId);
    enemyAttackIntervalId = null;
  }

  if (activeAlly && activeAlly.attackTimerId) {
    clearInterval(activeAlly.attackTimerId);
    activeAlly.attackTimerId = null;
  }

  toggleAutofire(false);

  for (let key in activeAmulets) {
    activeAmulets[key] = false;
  }

  playerStats.maxHp = playerStats.baseMaxHp;
  playerStats.currentHp = Math.min(playerStats.currentHp, playerStats.maxHp);
  updateHp(playerStats.currentHp);

  applyEquipmentBonuses();

  if (armorHealIntervalId) {
    clearInterval(armorHealIntervalId);
    armorHealIntervalId = null;
  }

  if (outcome === 'win') {

    let totalXp = activeEnemies.reduce((sum, enemy) => sum + (enemy.xpReward || 0), 0);
    gainXP(totalXp);

    playerStats.currentHp = playerStats.maxHp;
    updateHp(playerStats.currentHp);

    healAllyAfterBattle();

    if (defeatedZone) removeZone(defeatedZone);

  } else if (outcome === 'lose') {
    showGameOver();
  }

  activeEnemies = [];
  defeatedZone = null;
  activeAlly = null;
  draw();
  drawPartyStatus();
  const pbs = document.getElementById('player-battle-status');
  if (pbs) pbs.innerHTML = "";
}

function initiateBattle(zoneType, zoneObject) {
  inBattle = true;
  defeatedZone = { type: zoneType, object: zoneObject };
  resetAbilitiesForBattle();

  if (armorHealIntervalId) clearInterval(armorHealIntervalId);
  armorHealIntervalId = setInterval(passiveArmorHeal, 1000);

 staminaRegenIntervalId = setInterval(() => {
if (activeAmulets.stealing) return;
  let regenAmount = 1;
  if (activeAmulets.stamina) regenAmount += 1;
  
  updateStamina(playerStats.currentStamina + regenAmount);
  drawPlayerBattleStatus();
}, 100);
  
setInterval(() => {
  if (inBattle) updateAbilityButtonsUI();
}, 250);

  if (zoneObject && Array.isArray(zoneObject.encounter) && Array.isArray(zoneObject.encounter[0])) {
    currentRoundEncounters = zoneObject.encounter.map(round => Array.isArray(round) ? round.slice() : []);
  } else {
    currentRoundEncounters = [(zoneObject && zoneObject.encounter) ? zoneObject.encounter.slice() : []];
  }
  battleRounds = currentRoundEncounters.length;
  currentRoundIndex = 0;

  spawnRound(currentRoundIndex);
  
  if (equippedAllyId && unlockedAllies.has(equippedAllyId)) {
    const allyBase = alliesData.find(a => a.id === equippedAllyId);
    activeAlly = {
      id: allyBase.id,
      name: allyBase.name,
      baseMaxHp: allyBase.baseMaxHp, 
      baseDamage: allyBase.baseDamage,
      maxHp: allyBase.baseMaxHp,
      currentHp: allyBase.baseMaxHp,
      damage: allyBase.baseDamage,
      attackIntervalMs: allyBase.attackIntervalMs,
      level: allyBase.level,
      xp: allyBase.xp,
      xpToNextLevel: allyBase.xpToNextLevel,
      attackTimerId: null,
      stunned: false
    };
    startAllyAttacking();
    drawPartyStatus();
  } else {
    activeAlly = null;
  }

  selectedEnemyIndex = 0;
  drawBattleUI();
  drawPlayerBattleStatus();
  
  if (activeEnemies.length > 0 && activeEnemies[0].type === 'Dummy') {
    showBattleDialog([
      { speaker: 'Hero', text: "Starting battle dialogue here if needed." },
    ]);
  }

}

  function performEnemyAction(enemy) {
  if (!inBattle || isGameOver || enemy.currentHp <= 0) return;

  if (enemy.isStoned) {
    return;
  }
  

  if (!enemy.stunned) {
    let target = playerStats;
    if (activeAlly && activeAlly.currentHp > 0) {
      target = (Math.random() < 0.5) ? playerStats : activeAlly;
    }


    const behavior = enemyTypes[enemy.type]?.behavior || 'normalAttack';
  
   if (behavior === 'normalAttack') {
  normalAttack(enemy, target);
} else if (behavior === 'sniperAttack') {
  sniperAttack(enemy, target);
} else if (behavior === 'oldBotBehavior') {
  oldBotBehavior(enemy, target);
} else if (behavior === 'swordBehavior') {
  swordBehavior(enemy, target);
} else if (behavior === 'sandBehavior') {
  sandBehavior(enemy, target);
} else if (behavior === 'smokeBehavior') {
  smokeBehavior(enemy, target);
} else if (behavior === 'caveBossBehavior') {
  caveBossBehavior(enemy, target);
} else if (behavior === 'bossBehavior') {
  bossBehavior(enemy, target);
} else if (behavior === 'summonerBehavior') {
  summonerBehavior(enemy, target);
} else if (behavior === 'secondStageBossBehavior') {
  secondStageBossBehavior(enemy, target);
} else if (behavior === 'factoryBehavior') {
  factoryBehavior(enemy, target);
} else if (behavior === 'lifeCoreBehavior') {
  lifeCoreBehavior(enemy, target);
} else if (behavior === 'iceBossBehavior') {
  iceBossBehavior(enemy, target);
} else if (behavior === 'lifeStealBossBehavior') {
  lifeStealBossBehavior(enemy, target);
} else if (behavior === 'critBossBehavior') {
  critBossBehavior(enemy, target);
} else if (behavior === 'islandBossBehavior') {
  islandBossBehavior(enemy, target);
} else if (behavior === 'healerBehavior') {
  healerBehavior(enemy, target);
}

  drawBattleUI();
  drawPlayerBattleStatus();
    enemy.lastAttackAt = Date.now();
}
}
  setInterval(() => {
  if (!inBattle || isGameOver || _battleDialogPausedState) return;

  activeEnemies.forEach((enemy, index) => {
    enemy.attackTime = enemy.attackSpeed;
    const bar = document.getElementById(`attack-bar-${index}`);
    if (bar) {
      if (enemy.stunned) {
        bar.style.backgroundColor = "#555";
        return;
      }
      
      bar.style.backgroundColor = "#f00"; 
      const elapsed = Date.now() - enemy.lastAttackAt;
      const progress = Math.min(100, (elapsed / enemy.attackTime) * 100);
      bar.style.width = progress + "%";
      if (elapsed >= enemy.attackTime) {
        performEnemyAction(enemy);
        enemy.lastAttackAt = Date.now();
        enemy.attackTime = enemy.attackSpeed;
      }
    }
  });
}, 33);

function spawnRound(roundIdx) {
  const encounter = currentRoundEncounters[roundIdx] || [];
  const mult = getDifficultyMultipliers();

  const built = encounter.map(enemyData => {
    if (!enemyData) return null;

    const baseStats = enemyTypes[enemyData.type] || {};
    const finalMaxHp = Math.max(1, Math.floor((baseStats.maxHp || 10) * mult.enemyHp));
    const finalDamage = Math.max(0, Math.floor((baseStats.damage || 1) * mult.enemyDmg));

    const newEnemy = {
      ...enemyData,
      type: enemyData.type,
      name: baseStats.name || enemyData.type,
      maxHp: finalMaxHp,
      currentHp: finalMaxHp,
      damage: finalDamage,
      xpReward: baseStats.xpReward || 0,
      shieldActive: false,
      stunned: false,
      poisoned: false,
      resistances: baseStats.defaultResistances || { stun: false, poison: false },
      lastAttackAt: Date.now(),
      attackSpeed: baseStats.attackSpeed || 2000,
      attackTimerId: null
    };

    newEnemy.attackTimerId = setInterval(() => {
      if (typeof performEnemyAction === 'function') {
        performEnemyAction(newEnemy);
      }
    }, newEnemy.attackSpeed);

    return newEnemy;
  });

  activeEnemies = built.filter(Boolean);

  selectedEnemyIndex = 0;
  drawBattleUI();
  drawPlayerBattleStatus();
  startAbilityRegen();
}

  // Unlock an ally and update UI/save state
function unlockAlly(allyId) {
  if (!allyId) return;
  if (unlockedAllies.has(allyId)) {
    showTemporaryText(`${alliesData.find(a => a.id === allyId)?.name || allyId} is already unlocked.`);
    return;
  }
  const ally = alliesData.find(a => a.id === allyId);
  if (!ally) {
    console.warn('unlockAlly: unknown allyId', allyId);
    showTemporaryText('Unknown ally.');
    return;
  }

  unlockedAllies.add(allyId);
  // Auto-equip if nothing equipped yet
  if (!equippedAllyId) {
    equippedAllyId = allyId;
    showTemporaryText(`${ally.name} has joined and was auto-equipped.`);
  } else {
    showTemporaryText(`${ally.name} has joined your party!`);
  }
const ach = achievementsMap[`ally_unlock_${allyId}`];
  if (ach && !ach.unlocked) {
    ach.progress = 1;
    checkAchievements();
  }
  
  drawPartyList();
  drawPartyStatus();
}
  function triggerScreenShake() {
  const body = document.body;
  
  body.classList.remove('shaking');
  
  void body.offsetWidth; 
  
  body.classList.add('shaking');
  
  setTimeout(() => {
    body.classList.remove('shaking');
  }, 1000);
}

  function applyStonedEffect(enemy) {
  if (enemy.isStoned || enemy.isBoss) return;

  enemy.isStoned = true;
  drawBattleUI();

  setTimeout(() => {
    enemy.isStoned = false;
    drawBattleUI();
  }, 4000);
}

function checkAchievements() {
  achievements.forEach(ach => {
    if (!ach.unlocked && ach.checkCondition()) {
      ach.unlocked = true;
      showAchievementUnlocked(ach);
      drawAchievementsUI();
    }
  });
}
function triggerAbilityCooldown(name) {
  if (!ABILITIES[name]) return;
  abilityCooldowns[name] = ABILITIES[name].cooldownMs;
  updateAbilityButtonsUI();
}

// Implement ability effects
function doBlock() {
  if (abilityCooldowns.block > 0 || blockActive) {
    showTemporaryText('Block not ready.');
    return;
  }
  if (activeAmulets.stamina) {
  return;
}
  triggerAbilityCooldown('block');
  blockActive = true;
  updateAbilityButtonsUI();
  setTimeout(() => {
    blockActive = false;
    updateAbilityButtonsUI();
  }, ABILITIES.block.effectMs);
}

// Counter: opens a small timing window where incoming damage is countered
function doCounter() {
  if (abilityCooldowns.counter > 0 || counterWindowActive) {
    showTemporaryText('Counter not ready.');
    return;
  }
  if (activeAmulets.stamina) {
  return;
}
  triggerAbilityCooldown('counter');
  counterWindowActive = true;
  updateAbilityButtonsUI();

  setTimeout(() => {
    counterWindowActive = false;
    updateAbilityButtonsUI();
  }, ABILITIES.counter.windowMs);
}

function doCleanse() {
  if (abilityCooldowns.cleanse > 0 || playerStats.isFrozen) return;
  
  triggerAbilityCooldown('cleanse');

  const targets = [playerStats, activeAlly].filter(t => t !== null);
  let somethingWasRemoved = false;

  targets.forEach(target => {
    if (target._burnType || target.isBlinded || target.isFogged) {
      target._burnType = null;
      target.isBlinded = false;
      target.isFogged = false;
      target.isWeakened = false;
      somethingWasRemoved = true;
    }
  });

  if (somethingWasRemoved) {
    drawPlayerBattleStatus();
    drawBattleUI();
  }
}

  (function wireAbilityButtons() {
  const b = document.getElementById('ability-block');
  const c = document.getElementById('ability-counter');
  const cl = document.getElementById('ability-cleanse');
  if (b) b.addEventListener('click', doBlock);
  if (c) c.addEventListener('click', doCounter);
  if (cl) cl.addEventListener('click', doCleanse);
})();

  const keyBindings = {
  z: doBlock,
  x: doCounter,
  c: doCleanse
};

document.addEventListener("keydown", function(event) {
  if (!inBattle) return; 

  const fn = keyBindings[event.key.toLowerCase()];
  if (fn) fn();
});


  
(function installSimpleShop() {
  if (document.getElementById('simple-shop-popup')) return;

  
  const shopPrices = {
    bandaid: 6,
    emp_grenade: 10,
    extra_life: 20,
    poison_vial: 7,
    damage_potion: 9,
    stamina_potion: 5
  };

  const shopOverlay = document.createElement('div');
  shopOverlay.id = 'simple-shop-popup';
  Object.assign(shopOverlay.style, {
    display: 'none',
    position: 'fixed',
    inset: '0',
    zIndex: 5000,
    background: 'rgba(0,0,0,0.8)',
    alignItems: 'center',
    justifyContent: 'center'
  });

  const shopBox = document.createElement('div');
  Object.assign(shopBox.style, {
    width: '320px',
    maxWidth: '90vw',
    background: '#002591',
    border: '2px solid black',
    padding: '12px',
    boxSizing: 'border-box',
    fontFamily: "'Press Start 2P', sans-serif",
    color: 'white',
    textAlign: 'center'
  });

  shopBox.innerHTML = `
    <div style="margin-bottom:8px;"><strong>Battle Shop</strong></div>
    <div id="simple-shop-items" style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;"></div>
    <div style="display:flex;gap:8px;justify-content:center;">
      <button id="simple-shop-close" style="padding:8px;border:2px solid white;background:#333;color:white;cursor:pointer;">Close</button>
    </div>
    <div id="simple-shop-message" style="margin-top:8px;font-size:11px;color:#ffd"></div>
  `;

  shopOverlay.appendChild(shopBox);
  document.body.appendChild(shopOverlay);

  const itemsContainer = shopBox.querySelector('#simple-shop-items');
  const msgEl = shopBox.querySelector('#simple-shop-message');
  const closeBtn = shopBox.querySelector('#simple-shop-close');

  function renderShopItems() {
    itemsContainer.innerHTML = '';
    Object.keys(shopPrices).forEach(key => {
      const price = shopPrices[key];
      const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      const row = document.createElement('div');
      Object.assign(row.style, { display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: '8px' });
      row.innerHTML = `
        <div style="text-align:left;">
          <div style="font-size:11px;">${displayName}</div>
          <div style="font-size:10px;opacity:0.85;">Price: ${price} bolts</div>
        </div>
      `;
      const buyBtn = document.createElement('button');
      buyBtn.textContent = 'Buy';
      buyBtn.className = 'item-use-button';
      buyBtn.style.padding = '6px 8px';
      buyBtn.addEventListener('click', () => buyItem(key, price));
      row.appendChild(buyBtn);
      itemsContainer.appendChild(row);
    });
  }

  function buyItem(itemKey, price) {
    const bolts = inventory.get('bolts') || 0;
    if (bolts < price) {
      showShopMessage('Not enough bolts!');
      return;
    }
    inventory.set('bolts', bolts - price);
    const current = inventory.get(itemKey) || 0;
    inventory.set(itemKey, current + 1);

   
    showTemporaryText(`Bought ${itemKey.replace(/_/g,' ')} +1`);
    showShopMessage(`Purchased ${itemKey.replace(/_/g,' ')} for ${price} bolts.`);
    console.log(`Shop: bought ${itemKey}, new qty: ${inventory.get(itemKey)}, bolts left: ${inventory.get('bolts')}`);
  
    try { drawInventoryBattlePopup(); drawGeneralInventory(); } catch (e) {}
    updateHp(playerStats.currentHp); 
  }

  function showShopMessage(s) {
    if (!msgEl) return;
    msgEl.textContent = s;
    setTimeout(() => { if (msgEl) msgEl.textContent = ''; }, 2200);
  }

  closeBtn.addEventListener('click', () => {
    shopOverlay.style.display = 'none';
    draw();
  });


  window.openShop = function() {
    renderShopItems();
    shopOverlay.style.display = 'flex';
  };

  renderShopItems();
})();


function drawAchievementsUI() {
  achievementsPopup.innerHTML = '';
  achievements.forEach(ach => {
    const div = document.createElement('div');
    div.textContent = ach.unlocked ? `✓ ${ach.name}` : `🔒 ${ach.name}`;
    div.title = ach.unlocked ? '' : ach.description; 
    div.style.cursor = ach.unlocked ? 'default' : 'help';
    div.style.padding = '4px 0';
    if (ach.unlocked) div.style.color = 'lightgreen';
    else div.style.color = 'gray';
    achievementsPopup.appendChild(div);
  });
}

let achievementQueue = [];
let isShowingAchievement = false;

function showAchievementUnlocked(ach) {
  achievementQueue.push(ach);
  processAchievementQueue();
}

function processAchievementQueue() {
  if (isShowingAchievement || achievementQueue.length === 0) return;

  isShowingAchievement = true;
  const ach = achievementQueue.shift();
  
  const box = document.getElementById('achievement-popup-box');
  const nameEl = document.getElementById('ach-popup-name');
  const descEl = document.getElementById('ach-popup-desc');

  // my victory is unused but it sounds so good for achievements so why not
  const achSfx = new Audio('victory.wav'); 
  achSfx.volume = 0.5;
  achSfx.play().catch(e => {});

  nameEl.textContent = ach.name;
  descEl.textContent = ach.description;

  box.style.display = 'block';
  box.style.opacity = '1';
  setTimeout(() => {
    box.style.opacity = '0';
    
    setTimeout(() => {
      box.style.display = 'none';
      isShowingAchievement = false;
      processAchievementQueue();
    }, 1000); 

  }, 4000);
}
  
function checkInteraction(checkX, checkY) {
  const hitboxX = checkX + hitboxOffsetX;
  const hitboxY = checkY + hitboxOffsetY;
  if (!currentLevel.interactables) return null;
  for (const object of currentLevel.interactables) {
    const r = object.interactRect || { x: object.x, y: object.y, width: object.width, height: object.height };
    if (
      hitboxX < r.x + r.width &&
      hitboxX + hitboxWidth > r.x &&
      hitboxY < r.y + r.height &&
      hitboxY + hitboxHeight > r.y
    ) return object;
  }
  return null;
}
  
// Handle interaction actions
function handleInteraction(object) {
  if (!object) return;

  if (object.targetWallId) {
    const targetLvl = (typeof object.targetLevelIdx === 'number') ? object.targetLevelIdx : currentLevelIndex;
    removedWallIds.add(object.targetWallId);
    toggleWallById(object.targetWallId, false, targetLvl);
  }

  if (object.action === "recruit") {
    const preText = object.recruitDialog || [
      `You meet ${object.displayName || 'someone'}.`,
      'They might help you.'
    ];
    showDialog(preText, object.id, { style: object.dialogStyle || 'dialog', speaker: object.speaker || null });

    if (object.allyId) {
      unlockAlly(object.allyId);
    } else {
      console.warn('recruit object missing allyId', object);
      showTemporaryText('Nothing happened.');
    }

    currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
    draw();
    return;
  }

  if (object.action === "item_gate") {
    if (object.opened) {
      showDialog(object.messages?.opened || "You may go now.", object.dialogId);
      return;
    }

    const missingItems = (object.requiredItems || []).filter(item => (inventory.get(item) || 0) <= 0);
    if (missingItems.length > 0) {
      showDialog(object.messages?.needItems || "You need items to pass!", object.dialogId);
      return;
    }

    object.opened = true;
    if (object.wallId) {
      currentLevel.walls = currentLevel.walls.filter(wall => wall.id !== object.wallId);
    }
    showDialog(object.messages?.opened || "You may go now.", object.dialogId);
    draw();
    return;
  }

      if (object.action === "open_door" && object.id === "cardoor") {
  if (!gameFlags.carpass) {
    showDialog([
      { speaker: 'Bot', text: "Hey asshole! Fight us first!", style: 'npc' }
    ]);
    return;
  }

  loadLevel(object.destLevel, object.destX, object.destY);
  draw();
  return;
}


 if (object.action === 'shop') {
  window.openShop();
  return;
} 



if (object.action === 'lever') {

  if (typeof object.currentState === 'undefined') {
    object.currentState = !!object.initialState;
  }
  object.currentState = !object.currentState;

  showTemporaryText(object.currentState ? 'Lever turned on.' : 'Lever turned off.');

  // single
  if (object.leverType === 'single') {
    if (object.linkedWallId) {
      const targetLevelIndex = (typeof object.linkedLevelIndex === 'number')
        ? object.linkedLevelIndex
        : currentLevelIndex;
      toggleWallById(object.linkedWallId, !object.currentState, targetLevelIndex);
    }
  }

  // multi
  if (object.leverType === 'multi' && object.groupId) {
    evaluateMultiLeverGroup(object.groupId);
  }

  switch (object.id) {
    case 'leverblockade': {
      const targetLevel = levels[44];
      toggleWallById('wallblockade', !object.currentState, 44);
      if (targetLevel) {
        targetLevel.interactables = targetLevel.interactables.filter(i => i.id !== 'blockade');
        removedInteractableIds.add('blockade');
        targetLevel.walls = targetLevel.walls.filter(w => w.id !== 'wallblockade');
        removedWallIds.add('wallblockade');
      }
      break;
    }


    case 'atticlever2': {
      const targetLevel = levels[65];
      toggleWallById('arcadegate', !object.currentState, 65);
      gameFlags.atticlever = true;
      completeObjective();
      if (targetLevel) {
        targetLevel.interactables = targetLevel.interactables.filter(i => i.id !== 'visualarcadegate');
        removedInteractableIds.add('visualarcadegate');
        targetLevel.walls = targetLevel.walls.filter(w => w.id !== 'arcadegate');
        removedWallIds.add('arcadegate');
      }
      break;
    }

    case 'atticlever': {
      const targetLevel = levels[72];
      toggleWallById('atticwall', !object.currentState, 72);
      if (targetLevel) {
        targetLevel.interactables = targetLevel.interactables.filter(i => i.id !== 'atticblockade');
        removedInteractableIds.add('atticblockade');
        targetLevel.walls = targetLevel.walls.filter(w => w.id !== 'atticwall');
        removedWallIds.add('atticwall');
      }
      break;
    }
  }

  draw();
  return;
}



if (object.action === 'lever_controller') {
  if (object.groupId) {
    evaluateMultiLeverGroup(object.groupId, object);
  } else {
    showTemporaryText('Controller not linked to a group.');
  }
  return;
}



  if (object.action === "use_drill") {
  if ((inventory.get("drill") || 0) > 0) {
    showTemporaryText("You use the drill to break through the crack!");
    loadLevel(object.destLevel, object.destX, object.destY);
  } else {
    showTemporaryText("You need a drill to break through here.");
  }
  return;
}
  
  if (object.action === 'open_door' && !object.requiresKeycard) {
  loadLevel(object.destLevel, object.destX, object.destY);
  draw();
  return;
}


  if (object.requiresKeycard) {
    if ((inventory.get('keycard') || 0) > 0) {
      showTemporaryText("You used a keycard to activate this.");
     
      if (object.action === 'open_door') {
        loadLevel(object.destLevel, object.destX, object.destY);
      }
    
      currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
      draw();
    } else {
      showTemporaryText("You need a keycard to use this.");
    }
    return;
  }
  if (object.action === "password_door") {
  openPasswordPopup(object);
  return;
}

  if (object.action === "break") {
  const tool = object.requiredItem;
  if ((inventory.get(tool) || 0) > 0) {
    
    currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
    removedInteractableIds.add(object.id);

    currentLevel.walls = currentLevel.walls.filter(wall => {
      if (
        wall.x === object.x &&
        wall.y === object.y &&
        wall.width === object.width &&
        wall.height === object.height
      ) {
        removedWallIds.add(wall.id);
        return false;
      }
      return true;
    });
  }
}


  
if (object.action === "chest") {
  
  if (openedChestIds.has(object.id)) { 
    showDialog("The chest is empty.", null, { speaker: null });
    return;
  }

  object.opened = true;
  openedChestIds.add(object.id);

  const rewardLines = [];
  if (Array.isArray(object.rewards)) {
    for (const [key, qty] of object.rewards) {
      const current = inventory.get(key) || 0;
      inventory.set(key, current + (qty || 1));
      rewardLines.push(`+${qty || 1} ${key}`);
    }
  }

  achievementsMap['open_chests'].progress++;
  checkAchievements();
  const dialogText = ["You opened the chest!", "You received:"].concat(rewardLines);
  showDialog(dialogText, object.id, { speaker: null });

  draw();
  return;
}

  if (object.action === "pickup") {
    const key = object.itemName;
    const current = inventory.get(key) || 0;
    inventory.set(key, current + 1);
    currentLevel.interactables = currentLevel.interactables.filter(o => o !== object);
    removedInteractableIds.add(object.id);
    currentLevel.walls = currentLevel.walls.filter(w =>
      !(w.x === object.x && w.y === object.y && w.width === object.width && w.height === object.height)
    );
    showTemporaryText(`Picked up a ${key}!`);
    return;
  }
}
  
document.addEventListener('DOMContentLoaded', () => {
  const settingsButton = document.getElementById('settings-button');
  const settingsPopup = document.getElementById('settings-popup');
  const inventoryPopup = document.getElementById('inventory-popup');
  const partyPopup = document.getElementById('party-popup');
  const statsPopup = document.getElementById('stats-popup');

  const equipsBtn = document.getElementById('equips-button');
if (equipsBtn) {
  equipsBtn.style.display = 'inline-block';
  equipsBtn.onclick = () => {
    const popup = document.getElementById('equips-popup');
    const hidden = window.getComputedStyle(popup).display === 'none';
    popup.style.display = hidden ? 'flex' : 'none';
    if (!hidden) return;
    drawEquipsUI();
  };
}

function drawEquipsUI() {
  updateBox('slot-armor', equippedArmor ? armorTypes[equippedArmor].name : "Armor", !!equippedArmor);
  updateBox('slot-weapon', equippedWeapon ? weaponTypes[equippedWeapon].name : "Weapon", !!equippedWeapon);
  equippedGears.forEach((g, i) => {
    updateBox(`slot-gear-${i}`, g ? gearTypes[g].name : "Gear", !!g, g ? gearTypes[g].rarity : null);
  });

  document.getElementById('slot-armor').onclick = () => {
  if (equippedArmor === "virus") { 
    return;
  }
    if (equippedArmor) {
      const key = "armor_" + equippedArmor;
      inventory.set(key, (inventory.get(key) || 0) + 1);
      equippedArmor = null;
    }
    applyEquipmentBonuses();
    drawEquipsUI();
  };

  document.getElementById('slot-weapon').onclick = () => {
  if (equippedWeapon === "virus") {
  return;
  }
    if (equippedWeapon) {
      const key = "weapon_" + equippedWeapon;
      inventory.set(key, (inventory.get(key) || 0) + 1);
      equippedWeapon = null;
    }
    applyEquipmentBonuses();
    drawEquipsUI();
  };

  equippedGears.forEach((g, i) => {
    document.getElementById(`slot-gear-${i}`).onclick = () => {
      if (equippedGears[i]) {
        const key = "gear_" + equippedGears[i];
        inventory.set(key, (inventory.get(key) || 0) + 1);
        equippedGears[i] = null;
      }
      applyEquipmentBonuses();
      drawEquipsUI();
    };
  });

  const list = document.getElementById('equips-inventory-list');
  list.innerHTML = "";
  inventory.forEach((qty, key) => {
    if (qty <= 0) return;
    let item = null, type = "";

    if (key.startsWith("armor_")) { item = armorTypes[key.replace("armor_","")]; type="armor"; }
    if (key.startsWith("weapon_")) { item = weaponTypes[key.replace("weapon_","")]; type="weapon"; }
    if (key.startsWith("gear_")) { item = gearTypes[key.replace("gear_","")]; type="gear"; }

    if (item) {
      const div = document.createElement('div');
      div.style.padding = "10px";
      div.style.margin = "5px";
      div.style.background = "#002591";
      div.style.border = `2px solid ${type === 'gear' ? rarityColors[item.rarity] : 'white'}`;
      div.title = item.desc;
      div.innerHTML = `<strong>${item.name}</strong> <small>(${type})</small> <button class="item-use-button" style="float:right">Equip</button>`;
      div.querySelector('button').onclick = () => {
        if (type === 'gear') {
  const gearKey = key.replace("gear_", "");
  const qty = inventory.get(key) || 0;
  if (qty > 0) {
    const idx = equippedGears.indexOf(null);
    if (idx !== -1) {
      if (equippedGears[idx]) {
        const oldKey = "gear_" + equippedGears[idx];
        inventory.set(oldKey, (inventory.get(oldKey) || 0) + 1);
      }
      equippedGears[idx] = gearKey;
      inventory.set(key, qty - 1);
    }
  }
} else if (type === 'armor') {
    if (equippedArmor === "virus") {
        return; 
      }
  const armorKey = key.replace("armor_", "");
  const qty = inventory.get(key) || 0;
  if (qty > 0) {
    if (equippedArmor) {
      const oldKey = "armor_" + equippedArmor;
      inventory.set(oldKey, (inventory.get(oldKey) || 0) + 1);
    }
    equippedArmor = armorKey;
    inventory.set(key, qty - 1);
  }
    } else if (type === 'weapon') {
          if (equippedWeapon === "virus") {
            return;
          }
  const weaponKey = key.replace("weapon_", "");
  const qty = inventory.get(key) || 0;
  if (qty > 0) {
    if (equippedWeapon) {
      const oldKey = "weapon_" + equippedWeapon;
      inventory.set(oldKey, (inventory.get(oldKey) || 0) + 1);
     }
    equippedWeapon = weaponKey;
    inventory.set(key, qty - 1);
   }
}
        applyEquipmentBonuses();
        drawEquipsUI();
      };
      list.appendChild(div);
    }
  });
}

function updateBox(id, name, filled, rarity) {
  const el = document.getElementById(id);
  el.textContent = name;
  el.style.border = filled ? `3px solid ${rarity ? rarityColors[rarity] : 'white'}` : "2px dashed #666";
  el.style.background = filled ? "#003cbd" : "transparent";
}


  if (!settingsButton) return console.error('Settings wiring: missing #settings-button in DOM');
  if (!settingsPopup) return console.error('Settings wiring: missing #settings-popup in DOM');

  window.gameSettings = window.gameSettings || { difficulty: 'normal', showZones: false };


  settingsButton.addEventListener('click', () => {
    try {
      const hidden = window.getComputedStyle(settingsPopup).display === 'none';
      if (inventoryPopup) inventoryPopup.style.display = 'none';
      if (partyPopup) partyPopup.style.display = 'none';
      if (statsPopup) statsPopup.style.display = 'none';
      settingsPopup.style.display = hidden ? 'block' : 'none';
    } catch (e) {
      console.error('Settings wiring: toggle error', e);
    }
  });

  const difficultySelect = document.getElementById('difficulty-select');

  if (difficultySelect) difficultySelect.value = window.gameSettings.difficulty || 'normal';

  if (difficultySelect) {
    difficultySelect.addEventListener('change', (e) => {
      window.gameSettings.difficulty = e.target.value;
      if (typeof saveSettings === 'function') try { saveSettings(); } catch(_) {}
      if (typeof showTemporaryText === 'function') showTemporaryText(`Difficulty set to ${window.gameSettings.difficulty}`);
      else console.log(`Difficulty set to ${window.gameSettings.difficulty}`);
    });
  } else {
    console.warn('Settings wiring: no #difficulty-select found');
  }

const toggleAutosave = document.getElementById('toggle-autosave');
const toggleAutosaveMessage = document.getElementById('toggle-autosave-message');

if (toggleAutosave) {
  toggleAutosave.checked = !!gameSettings.autosave;
  toggleAutosave.addEventListener('change', (e) => {
    gameSettings.autosave = !!e.target.checked;
    saveSettings();
    showTemporaryText(gameSettings.autosave ? "Autosave Enabled" : "Autosave Disabled");
  });
}

if (toggleAutosaveMessage) {
  toggleAutosaveMessage.checked = !!gameSettings.autosaveMessage;
  toggleAutosaveMessage.addEventListener('change', (e) => {
    gameSettings.autosaveMessage = !!e.target.checked;
    saveSettings();
    showTemporaryText(gameSettings.autosaveMessage ? "Autosave Message Enabled" : "Autosave Message Disabled");
  });
}


  document.addEventListener("keydown", function(e) {
  if (!inBattle) return;
  const key = e.key.toLowerCase();

  const has = (name) => (inventory.get("amulet_" + name) || 0) > 0;

  if (key === 'q' && has("clicking")) {
     const isDialogActive = document.getElementById('dialog-overlay').style.display === 'flex';
        if (isDialogActive) {
        return;
      }
    activeAmulets.clicking = !activeAmulets.clicking;
    toggleAutofire(activeAmulets.clicking);
    showTemporaryText("Clicking Amulet: " + (activeAmulets.clicking ? "ON" : "OFF"));
  }

  if (key === 'w' && has("bullets")) {
    activeAmulets.bullets = !activeAmulets.bullets;
    showTemporaryText("Heightened Bullets: " + (activeAmulets.bullets ? "ON" : "OFF"));
  }

  if (key === 'e' && has("stamina")) {
    if (activeAmulets.stealing) {
       showTemporaryText("Conflict: Stealing Amulet is active!");
    } else {
       activeAmulets.stamina = !activeAmulets.stamina;
       showTemporaryText("Stamina Amulet: " + (activeAmulets.stamina ? "ON" : "OFF"));
    }
  }

  if (key === 'r' && has("health")) {
    activeAmulets.health = !activeAmulets.health;
    showTemporaryText("Health Amulet: " + (activeAmulets.health ? "ON" : "OFF"));
  }

if (key === 't' && has("stealing")) {
    if (activeAmulets.stamina) showTemporaryText("Conflict: Stamina Amulet active!");
    else activeAmulets.stealing = !activeAmulets.stealing;
  }

if (key === 'y' && has("sacrifice")) {
  activeAmulets.sacrifice = !activeAmulets.sacrifice;
  if (activeAmulets.sacrifice) {
    playerStats.maxHp = Math.floor(playerStats.baseMaxHp * 1.5);
    playerStats.currentHp = Math.min(playerStats.currentHp, playerStats.maxHp);

    updateHp(playerStats.currentHp);
    applyEquipmentBonuses();
  } else {
    playerStats.maxHp = playerStats.baseMaxHp;
    playerStats.currentHp = Math.min(playerStats.currentHp, playerStats.maxHp);

    if (activeAlly) {
      activeAlly.damage = activeAlly.baseDamage;
      activeAlly.maxHp = activeAlly.baseMaxHp;
      activeAlly.currentHp = Math.min(activeAlly.currentHp, activeAlly.maxHp);
    }

    applyEquipmentBonuses();
    updateHp(playerStats.currentHp);
  }
}
    
if (key === 'u' && has("xp")) {
  activeAmulets.xp = !activeAmulets.xp;
  if (activeAmulets.xp) {
    playerStats.maxHp = Math.floor(playerStats.baseMaxHp * 0.5);
    playerStats.currentHp = Math.min(playerStats.currentHp, playerStats.maxHp);

    updateHp(playerStats.currentHp);
    applyEquipmentBonuses();
  } else {
    playerStats.maxHp = playerStats.baseMaxHp;
    playerStats.currentHp = Math.min(playerStats.currentHp, playerStats.maxHp);

    applyEquipmentBonuses();
    updateHp(playerStats.currentHp);
  }
}



  if (key === 'i' && has("defense")) {
  if (activeAmulets.stamina) {
    showTemporaryText("Conflict: Stamina Amulet active!");
  } else {
    activeAmulets.defense = !activeAmulets.defense;
    if (activeAmulets.defense) {
      playerStats.maxHp = Math.floor(playerStats.baseMaxHp * 0.8);
      playerStats.currentHp = Math.min(playerStats.currentHp, playerStats.maxHp);

      updateHp(playerStats.currentHp);
    } else {
      playerStats.maxHp = playerStats.baseMaxHp;
      playerStats.currentHp = Math.min(playerStats.currentHp, playerStats.maxHp);

      updateHp(playerStats.currentHp);
    }
  }
}
drawBattleUI();
    drawPlayerBattleStatus();
    
});
  
const mobileToggle = document.getElementById('toggle-mobile-mode');
const mobileControls = document.getElementById('mobile-controls');

mobileToggle.addEventListener('change', (e) => {
  if (e.target.checked) {
    mobileControls.style.display = 'block';
    canvas.blur();
  } else {
    mobileControls.style.display = 'none';
  }
});

  function movePlayer(dx, dy) {
  if (inBattle || isGameOver) return;
  let nextX = x + dx * speed;
  let nextY = y + dy * speed;

  if (isInWater(nextX, nextY) && (inventory.get('raft') || 0) <= 0) {
    showTemporaryText("You need a raft to cross water!");
    return;
  }
  if (isInPoison(nextX, nextY) && (inventory.get('gas_mask') || 0) <= 0) {
    showTemporaryText("You need a gas mask to cross poison!");
    return;
  }
  if (!isCollidingWithWall(nextX, nextY)) {
   const door = checkDoorCollision(nextX, nextY);
if (door) {

  loadLevel(door.destLevel, door.destX, door.destY);
  
  if (door.dialog) {
    setTimeout(() => {
      showDialog(door.dialog, null, { 
        speaker: door.speaker || null, 
        style: door.style || 'dialog' 
      });
    }, 750);
  }
  return;
}
    const battleZone = findBattleZone(nextX, nextY);
    if (battleZone) {
      initiateBattle('battleZone', battleZone);
      return;
    }
    x = nextX;
    y = nextY;

    const dialogZone = findDialogZone(nextX, nextY);
    if (dialogZone && dialogZone.autoShow) {
      showDialog(dialogZone.text, dialogZone.id, { style: dialogZone.style || 'dialog', speaker: dialogZone.speaker || null });
      return;
    }
  }
  draw();
}
document.getElementById('btn-up').addEventListener('click', () => {
  movePlayer(0, -1);
  currentFacing = 'up';
});

document.getElementById('btn-down').addEventListener('click', () => {
  movePlayer(0, 1);
  currentFacing = 'down';
});

document.getElementById('btn-left').addEventListener('click', () => {
  movePlayer(-1, 0);
  currentFacing = 'left';
});

document.getElementById('btn-right').addEventListener('click', () => {
  movePlayer(1, 0);
  currentFacing = 'right';
});


document.getElementById('btn-interact').addEventListener('click', () => {
  if (inBattle || isGameOver) return;
 
  const interactableObject =
    checkInteraction(x - 16, y) ||
    checkInteraction(x + 16, y) ||
    checkInteraction(x, y - 16) ||
    checkInteraction(x, y + 16) ||
    checkInteraction(x, y);
  if (interactableObject) handleInteraction(interactableObject);
});
  
  function bindSlot(id, fn) {
    const el = document.getElementById(id);
    if (!el) { console.warn(`Settings wiring: missing ${id}`); return; }
    el.addEventListener('click', fn);
  }

  bindSlot('save-slot-1', () => { if (typeof saveToSlot === 'function') saveToSlot(1); else console.warn('saveToSlot not defined'); });
  bindSlot('save-slot-2', () => { if (typeof saveToSlot === 'function') saveToSlot(2); else console.warn('saveToSlot not defined'); });
  bindSlot('save-slot-3', () => { if (typeof saveToSlot === 'function') saveToSlot(3); else console.warn('saveToSlot not defined'); });

  bindSlot('load-slot-1', () => { if (typeof loadFromSlot === 'function') loadFromSlot(1); else if (typeof loadSlot === 'function') loadSlot(1); else console.warn('loadFromSlot not defined'); });
  bindSlot('load-slot-2', () => { if (typeof loadFromSlot === 'function') loadFromSlot(2); else console.warn('loadFromSlot not defined'); });
  bindSlot('load-slot-3', () => { if (typeof loadFromSlot === 'function') loadFromSlot(3); else console.warn('loadFromSlot not defined'); });

  console.log('Settings wiring installed');
});


const achievementsButton = document.getElementById('achievements-button');
const achievementsPopup = document.getElementById('achievements-popup');

achievementsButton.addEventListener('click', () => {
  if (achievementsPopup.style.display === 'none') {
    drawAchievementsUI();
    achievementsPopup.style.display = 'block';
  } else {
    achievementsPopup.style.display = 'none';
  }
});
  function spawnDamageNumber(enemyIndex, amount, color = "#ffffff") {
  const enemyButtons = document.querySelectorAll('.enemy-target');
  const targetBtn = Array.from(enemyButtons).find(b => parseInt(b.dataset.enemyIndex) === enemyIndex);
  
  if (!targetBtn) return;

  const rect = targetBtn.getBoundingClientRect();
  const dmgEl = document.createElement('div');
  dmgEl.className = 'damage-number';
  
  dmgEl.textContent = isNaN(amount) ? amount : `-${amount}`;
  dmgEl.style.color = color;

  dmgEl.style.left = (rect.left + rect.width / 2) + 'px';
  dmgEl.style.top = (rect.top) + 'px';

  document.body.appendChild(dmgEl);

  setTimeout(() => {
    dmgEl.remove();
  }, 1000);
}
  

const pewBuffer = new Audio('pew.mp3');
pewBuffer.volume = 0.2;

function performPlayerAttack() {
  const pewSound = pewBuffer.cloneNode();
  pewSound.volume = 0.4;
  pewSound.play();

  if (!inBattle || !activeEnemies.length) return;
  const targetEnemy = activeEnemies[selectedEnemyIndex];
  if (!targetEnemy) return;

  if (targetEnemy.isStoned) {
    spawnDamageNumber(selectedEnemyIndex, "BLOCKED", "#aaaaaa");
    return;
  }
  
  if (playerStats.isBlinded && Math.random() < 0.5) {
    spawnDamageNumber(selectedEnemyIndex, "MISS", "#aaaaaa");
    return;
  }

if (activeAmulets.bullets && playerStats.currentStamina < 3) {
    showTemporaryText("Not enough stamina to fire!");
    return;
  }
  if (targetEnemy.shieldActive) {
    spawnDamageNumber(selectedEnemyIndex, "BLOCKED", "#00ffff");
  } else {
    let finalDmg = playerStats.damage;
    if (activeAmulets.bullets) finalDmg *= 1.5;
    if (activeAmulets.health) finalDmg *= 0.5;
    if (activeAmulets.sacrifice) finalDmg *= 1.5;
    if (activeAmulets.xp) finalDmg *= 0.5;
    if (playerStats.isWeakened) {
    finalDmg *= 0.5;
  }
    finalDmg = Math.floor(finalDmg);
    targetEnemy.currentHp -= finalDmg;
    spawnDamageNumber(selectedEnemyIndex, finalDmg);

    if (activeAmulets.health) {
        if (!playerStats.isBleeding) {
       updateHp(playerStats.currentHp + finalDmg);
    }
  }

    if (activeAmulets.bullets) {
       updateStamina(playerStats.currentStamina - 3);
    }
  }

  if (activeAmulets.stealing) {
        targetEnemy.lastAttackAt += 50; 
        targetEnemy.lastAttackAt += 50; 
    }
  
  if (playerStats.isBleeding) {
    playerStats.currentHp = Math.max(1, playerStats.currentHp - 1);
    updateHp(playerStats.currentHp);
  }

  const statueCount = equippedGears.filter(g => g === 'statue_gear').length;
  if (statueCount > 0 && Math.random() < (0.01 * statueCount)) {
    applyStonedEffect(targetEnemy);
  }

  const stealCount = equippedGears.filter(g => g === 'steal_gear').length;
    if (stealCount > 0) {
        targetEnemy.attackTime += (10 * stealCount);
        targetEnemy.lastAttackAt += (10 * stealCount);
    }
  if (targetEnemy.currentHp <= 0) {
    handleEnemyDeath(targetEnemy);
    if (selectedEnemyIndex >= activeEnemies.length) {
      selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
    }
  }

  activeEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);
  if (activeEnemies.length === 0) {
    endBattle('win');
    return;
  }

  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
}

document.getElementById('attack-button').addEventListener('click', () => {
  if (activeAmulets.clicking) return; 
  performPlayerAttack();
});


document.getElementById('special-attack-button-1').addEventListener('click', () => {
  const staminaCost = 100;
  if (!inBattle || !activeEnemies.length || playerStats.currentStamina < staminaCost) {
    showTemporaryText("Not enough stamina!");
    return;
  }
  const specialAttack = new Audio('explosion.wav');
specialAttack.play();
  updateStamina(playerStats.currentStamina - staminaCost);
  const targetEnemy = activeEnemies[selectedEnemyIndex];
  if (!targetEnemy) return;
  targetEnemy.currentHp -= (playerStats.damage * 10);
  if (targetEnemy.currentHp < 0) targetEnemy.currentHp = 0;
  if (targetEnemy.currentHp === 0) {
    handleEnemyDeath(targetEnemy);
    
    if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = Math.max(0, activeEnemies.length - 1);
    return;
  }
  let remainingEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);
  if (remainingEnemies.length === 0) {
    endBattle('win');
    return;
  }
  activeEnemies = remainingEnemies;
  if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = 0;
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
});

document.getElementById('special-attack-button-2').addEventListener('click', () => {
  const staminaCost = 200;
  if (!inBattle || playerStats.currentStamina < staminaCost) {
    showTemporaryText("Not enough stamina!");
    return;
  }
  updateStamina(playerStats.currentStamina - staminaCost);

  if (equippedWeapon === "virus") {
    
    activeEnemies.forEach(enemy => {
      enemy.currentHp -= playerStats.damage * 30;
      if (enemy.currentHp < 0) enemy.currentHp = 0;

     
      if (!enemy.isBoss && !enemy.poisoned) {
        enemy.poisoned = false;
       
      }
    });
  } else {
    const specialAttack = new Audio('explosion.wav');
specialAttack.play();
    activeEnemies.forEach(enemy => {
      enemy.currentHp -= playerStats.damage * 20;
      if (enemy.currentHp < 0) enemy.currentHp = 0;
    });
  }

  
  activeEnemies = activeEnemies.filter(enemy => enemy.currentHp > 0);

  if (activeEnemies.length === 0) {
    endBattle('win');
    return;
  }
  if (selectedEnemyIndex >= activeEnemies.length) selectedEnemyIndex = 0;
  drawBattleUI();
  drawPartyStatus();
  drawPlayerBattleStatus();
});


document.getElementById('enemy-display').addEventListener('click', (event) => {
  const button = event.target.closest('.enemy-target');
  if (button) {
    selectedEnemyIndex = parseInt(button.dataset.enemyIndex);
    drawBattleUI();
  }
});


document.getElementById('stats-button').addEventListener('click', () => {
  if (statsPopup.style.display === 'none') {
    updateStatsPopup();
    statsPopup.style.display = 'block';
  } else {
    statsPopup.style.display = 'none';
  }
});

updateHp(playerStats.currentHp);


document.getElementById('inventory-battle-button').addEventListener('click', () => {
  const inventoryPopupBattle = document.getElementById('inventory-battle-popup');
  if (inventoryPopupBattle.style.display === 'none') {
    drawInventoryBattlePopup();
    inventoryPopupBattle.style.display = 'block';
  } else {
    inventoryPopupBattle.style.display = 'none';
  }
});

  const loadTitleBtn = document.getElementById('load-title-button');

loadTitleBtn.addEventListener('click', () => {
  const saved = localStorage.getItem('8bitsAdventureSave');
  
  if (!saved) {
    return;
  }

  titleScreen.style.display = 'none';
  loadGame();

  if (objectiveBox) objectiveBox.style.display = 'block';

  draw();
  updateStatsPopup();
  drawPartyStatus();
});

  document.getElementById('dialog-next').addEventListener('click', () => {
  const overlay = document.getElementById('dialog-overlay');
  const textDiv = document.getElementById('dialog-text');
  const box = document.getElementById('dialog-box');

  if (_isTyping) {
    finishTyping(textDiv);
    return; 
  }
  let nextLine = null;

  if (Array.isArray(_battleDialogQueue) && _battleDialogQueue.length > 0) {
    nextLine = _battleDialogQueue.shift();
  } else if (_dialogQueue && _dialogQueue.length > 0) {
    nextLine = _dialogQueue.shift();
  }

if (nextLine) {
  applyDialogStyle(box, nextLine.style || 'dialog');
  startTypewriter(nextLine.text, textDiv, nextLine.speaker, nextLine.effect); 
  return;
}

  const id = overlay._markId;
  overlay._markId = null;
  overlay.style.display = 'none';

    if (overlay._onComplete) {
    const callback = overlay._onComplete;
    overlay._onComplete = null;
    callback();
  }
  
  if (id) shownDialogs.add(id);
  if (inBattle) {
    resumeBattleTimersAfterDialog();
  }
  draw();
});


document.addEventListener('keydown', function(e) {
  if (isGameOver && e.key.toLowerCase() === 'r') {
    location.reload();
  }
});

function loadLevel(index, newX = x, newY = y) {
  const fadeEl = document.getElementById('fade-overlay');
  fadeEl.style.opacity = '1';

  if (gameSettings.autosave) {
    saveGame();
    if (gameSettings.autosaveMessage) showTemporaryText("Autosaving...");
  }


  const nextBg = new Image();
  const nextLevelData = levels[index];

  const finalizeLoad = () => {
    currentLevelIndex = index;
    currentLevel = nextLevelData;
    bgImg = nextBg;
    x = newX;
    y = newY;
    
    draw();
    
    setTimeout(() => {
      fadeEl.style.opacity = '0';
    }, 100); 
  };

  nextBg.onload = finalizeLoad; 

  nextBg.onerror = () => {
    console.warn("Resource Load Error: Background image not found or offline. Falling back to default color.");

    finalizeLoad();
  };

  setTimeout(() => {
    nextBg.src = nextLevelData.bgSrc;
  }, 500);
}


function isInZone(zones, px, py) {
  if (!zones) return false;
  const hitboxX = px + hitboxOffsetX;
  const hitboxY = py + hitboxOffsetY;
  for (const zone of zones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) {
      return true;
    }
  }
  return false;
}

function isInWater(px, py) {
  return isInZone(currentLevel.waterZones, px, py);
}

function isInPoison(px, py) {
  return isInZone(currentLevel.poisonZones, px, py);
}
function isInIce(px, py) {
  if (!currentLevel.iceZones) return false;
  const hitboxX = px + hitboxOffsetX;
  const hitboxY = py + hitboxOffsetY;
  for (const zone of currentLevel.iceZones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) return true;
  }
  return false;
}

function isCollidingWithWall(newX, newY) {
  const newHitboxX = newX + hitboxOffsetX;
  const newHitboxY = newY + hitboxOffsetY;
  for (const wall of currentLevel.walls) {
    if (
      newHitboxX < wall.x + wall.width &&
      newHitboxX + hitboxWidth > wall.x &&
      newHitboxY < wall.y + wall.height &&
      newHitboxY + hitboxHeight > wall.y
    ) {
      return true;
    }
  }
  return false;
}

  function startSlide(dx, dy) {
  if ((inventory.get('ice_boots') || 0) > 0) return;
  sliding = true;
  slidingDirection = { dx: Math.sign(dx), dy: Math.sign(dy) };
  if (slidingIntervalId) { clearInterval(slidingIntervalId); slidingIntervalId = null; }

  slidingIntervalId = setInterval(() => {
    if (!sliding) { stopSlide(); return; }

    const nextX = x + slidingDirection.dx * speed;
    const nextY = y + slidingDirection.dy * speed;

    if (isCollidingWithWall(nextX, nextY)) { stopSlide(); return; }

    const door = checkDoorCollision(nextX, nextY);
    if (door) { loadLevel(door.destLevel, door.destX, door.destY); stopSlide(); return; }

    const battleZone = findBattleZone(nextX, nextY);
    if (battleZone) { x = nextX; y = nextY; initiateBattle('battleZone', battleZone); stopSlide(); return; }

    x = nextX;
    y = nextY;

    if (!isInIce(x, y)) { stopSlide(); return; }

    draw();
  }, SLIDE_STEP_MS);
}

  function stopSlide() {
  if (!sliding) return;
  sliding = false;
  slidingDirection = { dx: 0, dy: 0 };
  if (slidingIntervalId) {
    clearInterval(slidingIntervalId);
    slidingIntervalId = null;
  }
  draw();
}
function tryEnterSlideIfNeeded(oldX, oldY, newX, newY, dx, dy) {
  if ((inventory.get('ice_boots') || 0) > 0) return false;
  const wasInIce = isInIce(oldX, oldY);
  const nowInIce = isInIce(newX, newY);
  if (!wasInIce && nowInIce) {
    startSlide(dx, dy);
    return true;
  }
  return false;
}
  
function checkDoorCollision(newX, newY) {
  const newHitboxX = newX + hitboxOffsetX;
  const newHitboxY = newY + hitboxOffsetY;
  for (const door of currentLevel.doors) {
    if (
      newHitboxX < door.x + door.width &&
      newHitboxX + hitboxWidth > door.x &&
      newHitboxY < door.y + door.height &&
      newHitboxY + hitboxHeight > door.y
    ) {
      return door;
    }
  }
  return null;
}


function draw() {
  if (inBattle || isGameOver) return;

  
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  
  if (bgImg && bgImg.complete && bgImg.naturalWidth > 0) {
    ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
  } else {
    
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  ctx.fillStyle = "rgba(0,0,0,0.0)";
  for (const wall of currentLevel.walls) {
    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
  }
  
  drawBreathing();
 
const activeSprite = playerSprites[currentFacing];

if (useImage && activeSprite.complete && activeSprite.naturalWidth > 0) {
  ctx.drawImage(activeSprite, x, y, imageSize, imageSize);
} else {
  ctx.fillStyle = "#0090ff";
  ctx.fillRect(x, y, imageSize, imageSize);
}
  
if (window.gameSettings && window.gameSettings.showZones) {
  ctx.save();
  ctx.strokeStyle = 'yellow';
  ctx.lineWidth = 2;
  ctx.strokeRect(x + hitboxOffsetX + 0.5, y + hitboxOffsetY + 0.5, hitboxWidth, hitboxHeight);
}

  if (tempText) {
    ctx.fillStyle = "white";
    ctx.font = "12px 'Press Start 2P'";
    ctx.textAlign = "center";
    const maxWidth = canvas.width - 40;
    const lineHeight = 15;
    const startY = canvas.height - 100;
    wrapText(ctx, tempText, canvas.width / 2, startY, maxWidth, lineHeight);
  }

if (gameSettings.showZones) {
 
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,0,0.9)';
  ctx.lineWidth = 2;
  currentLevel.walls.forEach(w => {
    ctx.strokeRect(w.x + 0.5, w.y + 0.5, w.width, w.height);
  });

  ctx.strokeStyle = 'rgba(0,255,255,0.9)';
  currentLevel.interactables.forEach(obj => {
    ctx.strokeRect(obj.x + 0.5, obj.y + 0.5, obj.width, obj.height);
  });

  ctx.strokeStyle = 'rgba(255,0,0,0.9)';
  (currentLevel.battleZones || []).forEach(z => {
    const r = z.interactRect || { x: z.x, y: z.y, width: z.width, height: z.height };
    ctx.strokeRect(r.x + 0.5, r.y + 0.5, r.width, r.height);
  });
  ctx.restore();
}

  currentLevel.interactables.forEach(obj => {
  if (obj.action === "pickup") {
 
    let imgToDraw = null;
    if (obj.name === "hammer") imgToDraw = hammerImg;
    else if (obj.name === "keycard") imgToDraw = keycardImg;
    else if (obj.name === "gas_mask") imgToDraw = gasMaskImg;
    else if (obj.name === "laser_cutter") imgToDraw = laserCutterImg;
    else if (obj.name === "raft") imgToDraw = raftImg;
    else if (obj.name === "torch") imgToDraw = torchImg;
    else if (obj.name === "dmgPotion") imgToDraw = dmgPotionImg;
    else if (obj.name === "staminaPotion") imgToDraw = stmPotionImg;
    else if (obj.name === "drill") imgToDraw = drillImg;

    if (imgToDraw && imgToDraw.complete) {
      ctx.drawImage(imgToDraw, obj.x, obj.y, obj.width, obj.height);
    } else {
      ctx.fillStyle = "#cc9900"; 
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }
  } else if (obj.action === "break" && obj.name === "steel_block") {
    if (steelBlockImg.complete) {
      ctx.drawImage(steelBlockImg, obj.x, obj.y, obj.width, obj.height);
    } else {
      ctx.fillStyle = "#888";
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }
  }
});

(currentLevel.interactables || []).forEach(obj => {
  if (!obj) return;
  if (obj.action === 'lever') {
    if (typeof obj.currentState === 'undefined') obj.currentState = !!obj.initialState;
    const imgToDraw = obj.currentState ? leverOnImg : leverOffImg;
    if (imgToDraw && imgToDraw.complete && imgToDraw.naturalWidth > 0) {
    
      const w = obj.width || 16;
      const h = obj.height || 16;
      ctx.drawImage(imgToDraw, obj.x, obj.y, w, h);
    } else {
      ctx.fillStyle = obj.currentState ? '#00cc00' : '#663300';
      ctx.fillRect(obj.x, obj.y, obj.width || 12, obj.height || 12);
    }
  } else if (obj.action === 'lever_controller') {
  
    ctx.fillStyle = '#8844ff';
    ctx.fillRect(obj.x, obj.y, obj.width || 12, obj.height || 12);
    ctx.fillStyle = 'white';
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('C', (obj.x + (obj.width || 12) / 2), obj.y + (obj.height || 12) / 1.4);
  }
});

currentLevel.interactables.forEach(obj => {
  if (obj.action === "chest") {
    if (obj.opened) {
   
      if (openChestImg && openChestImg.complete) ctx.drawImage(openChestImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#775533"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    } else {
      
      if (closedChestImg && closedChestImg.complete) ctx.drawImage(closedChestImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#aa7722"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    }
  }
});
  if (currentLevel.waterZones) {
  ctx.fillStyle = "rgba(0, 0, 255, 0.9)";
  currentLevel.waterZones.forEach(zone => {
    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
  });
}
  if (currentLevel.iceZones) {
  ctx.fillStyle = "rgba(0, 255, 255, 0.3)";
  currentLevel.iceZones.forEach(zone => {
    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
  });
}
function isInDarkZone(px, py) {
  if (!currentLevel.darkZones) return false;
  const hitboxX = px + hitboxOffsetX;
  const hitboxY = py + hitboxOffsetY;
  for (const zone of currentLevel.darkZones) {
    if (
      hitboxX < zone.x + zone.width &&
      hitboxX + hitboxWidth > zone.x &&
      hitboxY < zone.y + zone.height &&
      hitboxY + hitboxHeight > zone.y
    ) {
      return true;
    }
  }
  return false;
}

if (currentLevel.poisonZones) {
  ctx.fillStyle = "rgba(0, 255, 0, 0.4)";
  currentLevel.poisonZones.forEach(zone => {
    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
  });
}

if (isInDarkZone(x, y) && (inventory.get("torch") || 0) <= 0) {

  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}


  currentLevel.interactables.forEach(obj => {
    if (obj.name === "big_stone" || obj.name === "bigStone") {
      if (stoneImg.complete) ctx.drawImage(stoneImg, obj.x, obj.y, obj.width, obj.height);
      else { ctx.fillStyle = "#888"; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }
    }
  });
}

  setInterval(() => {
  draw();
}, 1000 / 30);

const SETTINGS_KEY = '8bitsAdventureSettings';
const SAVE_SLOT_PREFIX = '8bitsAdventureSave_slot_'; 

const defaultSettings = {
  difficulty: 'normal',
  showZones: false,
  autosave: true, 
  autosaveMessage: true 
};

let gameSettings = Object.assign({}, defaultSettings);

function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      Object.assign(gameSettings, parsed);
    }
  } catch (e) {
    console.error('Failed to load settings', e);
  }
 
  const sel = document.getElementById('difficulty-select');
  if (sel) sel.value = gameSettings.difficulty || 'normal';
}
function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
  } catch (e) {
    console.error('Failed to save settings', e);
  }
}

function saveToSlot(slotNumber) {
  const key = SAVE_SLOT_PREFIX + slotNumber;
  const saveData = {
    playerStats,
    inventory: Array.from(inventory.entries()),
    currentLevelIndex,
    playerPosition: { x, y },
    shownDialogs: Array.from(shownDialogs),
    gameFlags,
    goodPoints: goodPoints,
    badPoints: badPoints,
    currentObjective,
    objectiveCompleted,
    alliesData: alliesData.filter(a => unlockedAllies.has(a.id)).map(a => ({
      id: a.id,
      level: a.level,
      xp: a.xp,
      xpToNextLevel: a.xpToNextLevel,
      baseMaxHp: a.baseMaxHp,
      baseDamage: a.baseDamage
    })),
    unlockedAllies: Array.from(unlockedAllies),
    equippedAllyId,
    removedWallIds: Array.from(removedWallIds),
    removedInteractableIds: Array.from(removedInteractableIds),
    removedBattleZoneIds: Array.from(removedBattleZoneIds),
    openedChestIds: Array.from(openedChestIds || []),
    achievements: achievements.map(a => ({
      id: a.id,
      progress: a.progress,
      unlocked: a.unlocked
    })),
    settings: gameSettings
  };
  localStorage.setItem(key, JSON.stringify(saveData));
  showTemporaryText(`Saved to slot ${slotNumber}`);
}
function loadFromSlot(slotNumber) {
  const key = SAVE_SLOT_PREFIX + slotNumber;
  const raw = localStorage.getItem(key);
  if (!raw) {
    showTemporaryText(`No save in slot ${slotNumber}`);
    return;
  }
  try {
    const saveData = JSON.parse(raw);

    Object.assign(playerStats, saveData.playerStats);
    inventory.clear();
    saveData.inventory.forEach(([k, v]) => inventory.set(k, v));

    Object.assign(gameFlags, saveData.gameFlags || {});
    if (saveData.currentObjective) {
      setObjective(saveData.currentObjective);
      if (saveData.objectiveCompleted) completeObjective();
    }
goodPoints = saveData.goodPoints || 0;
badPoints = saveData.badPoints || 0;
    removedInteractableIds = new Set(saveData.removedInteractableIds || []);
    removedWallIds = new Set(saveData.removedWallIds || []);
    shownDialogs = new Set(saveData.shownDialogs || []);
    openedChestIds = new Set(saveData.openedChestIds || []);
    removedBattleZoneIds = new Set(saveData.removedBattleZoneIds || []);

levels.forEach(level => {
  if (level.battleZones) {
    level.battleZones = level.battleZones.filter(bz => !removedBattleZoneIds.has(bz.id));
  }
});

    levels.forEach(level => {
      level.interactables = level.interactables.filter(i => !removedInteractableIds.has(i.id));
      level.interactables.forEach(i => {
        if (openedChestIds.has(i.id)) {
  i.opened = true;
}
      });
      level.walls = level.walls.filter(w => !removedWallIds.has(w.id));
    });

    if (Array.isArray(saveData.alliesData)) {
      saveData.alliesData.forEach(savedAlly => {
        const baseAlly = alliesData.find(a => a.id === savedAlly.id);
        if (baseAlly) Object.assign(baseAlly, savedAlly);
      });
    }
    unlockedAllies = new Set(saveData.unlockedAllies || []);
    equippedAllyId = saveData.equippedAllyId || null;
    if (equippedAllyId && unlockedAllies.has(equippedAllyId)) {
      const allyBase = alliesData.find(a => a.id === equippedAllyId);
      activeAlly = { ...allyBase, currentHp: allyBase.baseMaxHp, attackTimerId: null };
    } else {
      activeAlly = null;
    }

    if (Array.isArray(saveData.achievements)) {
      saveData.achievements.forEach(savedAch => {
        const ach = achievementsMap[savedAch.id];
        if (ach) {
          ach.progress = savedAch.progress || 0;
          ach.unlocked = !!savedAch.unlocked;
        }
      });
    }

    if (saveData.settings) {
      Object.assign(gameSettings, saveData.settings);
      const sel = document.getElementById('difficulty-select');
      if (sel) sel.value = gameSettings.difficulty;
    }

    loadLevel(saveData.currentLevelIndex, saveData.playerPosition.x, saveData.playerPosition.y);

    updateHp(playerStats.currentHp);
    updateStatsPopup();
    drawAchievementsUI();
    drawPartyList();
    drawPartyStatus();

    showTemporaryText(`Loaded slot ${slotNumber}`);
  } catch (e) {
    console.error('Failed to load slot', e);
    showTemporaryText('Failed to load save');
  }
}

document.getElementById('save-slot-1').addEventListener('click', () => saveToSlot(1));
document.getElementById('save-slot-2').addEventListener('click', () => saveToSlot(2));
document.getElementById('save-slot-3').addEventListener('click', () => saveToSlot(3));
document.getElementById('load-slot-1').addEventListener('click', () => loadFromSlot(1));
document.getElementById('load-slot-2').addEventListener('click', () => loadFromSlot(2));
document.getElementById('load-slot-3').addEventListener('click', () => loadFromSlot(3));

document.getElementById('difficulty-select').addEventListener('change', (e) => {
  gameSettings.difficulty = e.target.value;
  saveSettings();
  showTemporaryText(`Difficulty set to ${gameSettings.difficulty}`);
});



loadSettings();

function saveGame() {
  const saveData = {
  playerStats,
  inventory: Array.from(inventory.entries()),
  currentLevelIndex,
  playerPosition: { x, y },
  shownDialogs: Array.from(shownDialogs),
    gameFlags: gameFlags,
    goodPoints: goodPoints,
    badPoints: badPoints,
    currentObjective: currentObjective,
    objectiveCompleted: objectiveCompleted,
  alliesData: alliesData.filter(a => unlockedAllies.has(a.id)).map(a => ({
    id: a.id,
    level: a.level,
    xp: a.xp,
    xpToNextLevel: a.xpToNextLevel,
    baseMaxHp: a.baseMaxHp,
    baseDamage: a.baseDamage
  })),
  unlockedAllies: Array.from(unlockedAllies),
  equippedAllyId,
  removedWallIds: Array.from(removedWallIds),
  removedInteractableIds: Array.from(removedInteractableIds),
  removedBattleZoneIds: Array.from(removedBattleZoneIds),
  openedChestIds: Array.from(openedChestIds || []) 
};
  saveData.achievements = achievements.map(a => ({
  id: a.id,
  progress: a.progress,
  unlocked: a.unlocked
}));
  localStorage.setItem('8bitsAdventureSave', JSON.stringify(saveData));
  console.log('Game saved:', saveData);
}

  function exportSave() {
  const rawSave = localStorage.getItem("8bitsAdventureSave");
  document.getElementById("export-box").value = rawSave || "No save found";
}


function openExportMenu() {
  exportSave();
  document.getElementById("export-menu").style.display = "block";
}

function closeExportMenu() {
  document.getElementById("export-menu").style.display = "none";
}

document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "q") {
    if (!devMode) return;
    openExportMenu();
  }
});

document.getElementById("close-export").addEventListener("click", closeExportMenu);


function loadGame() {
  const saved = localStorage.getItem('8bitsAdventureSave');
  if (!saved) {
    showTemporaryText('No saved game found.');
    console.log('No saved game found.');
    return;
  }

  try {
    const saveData = JSON.parse(saved);

 
    Object.assign(playerStats, saveData.playerStats);
    inventory.clear();
    saveData.inventory.forEach(([key, value]) => inventory.set(key, value));


    Object.assign(gameFlags, saveData.gameFlags || {});
    if (saveData.currentObjective) {
      setObjective(saveData.currentObjective);
      if (saveData.objectiveCompleted) completeObjective();
    }

    goodPoints = saveData.goodPoints || 0;
    badPoints = saveData.badPoints || 0;
 
    removedInteractableIds = new Set(saveData.removedInteractableIds || []);
    removedWallIds = new Set(saveData.removedWallIds || []);
    shownDialogs = new Set(saveData.shownDialogs || []);
    openedChestIds = new Set(saveData.openedChestIds || []);
    removedBattleZoneIds = new Set(saveData.removedBattleZoneIds || []);

levels.forEach(level => {
  if (level.battleZones) {
    level.battleZones = level.battleZones.filter(bz => !removedBattleZoneIds.has(bz.id));
  }
});
  
    levels.forEach(level => {

      level.interactables = level.interactables.filter(i => !removedInteractableIds.has(i.id));

  
      level.interactables.forEach(i => {
        if (openedChestIds.has(i.id)) {
  i.opened = true;
}
      });

      
      level.walls = level.walls.filter(w => !removedWallIds.has(w.id));
    });

  
    if (Array.isArray(saveData.alliesData)) {
      saveData.alliesData.forEach(savedAlly => {
        const baseAlly = alliesData.find(a => a.id === savedAlly.id);
        if (baseAlly) {
          Object.assign(baseAlly, savedAlly);
        }
      });
    }
    unlockedAllies = new Set(saveData.unlockedAllies || []);
    equippedAllyId = saveData.equippedAllyId || null;
    if (equippedAllyId && unlockedAllies.has(equippedAllyId)) {
      const allyBase = alliesData.find(a => a.id === equippedAllyId);
      activeAlly = { ...allyBase, currentHp: allyBase.baseMaxHp, attackTimerId: null };
    } else {
      activeAlly = null;
    }

   
    if (Array.isArray(saveData.achievements)) {
      saveData.achievements.forEach(savedAch => {
        const ach = achievementsMap[savedAch.id];
        if (ach) {
          ach.progress = savedAch.progress || 0;
          ach.unlocked = !!savedAch.unlocked;
        }
      });
    }

  
    loadLevel(saveData.currentLevelIndex, saveData.playerPosition.x, saveData.playerPosition.y);

 
    updateHp(playerStats.currentHp);
    updateStatsPopup();
    drawAchievementsUI();

    showTemporaryText('Game loaded!');
    console.log('Game loaded:', saveData);

  } catch (e) {
    console.error('Failed to load save:', e);
    showTemporaryText('Failed to load save.');
  }
}


  function rebuildWalls() {
  levels.forEach(level => {
    if (!level.walls || !level.interactables) return;
    const interactableRects = level.interactables.map(obj => ({
      x: obj.x,
      y: obj.y,
      width: obj.width,
      height: obj.height
    }));
    level.walls = level.walls.filter(wall => {
      return !interactableRects.some(rect => (
        wall.x === rect.x &&
        wall.y === rect.y &&
        wall.width === rect.width &&
        wall.height === rect.height
      ));
    });
  });
}

const devConsole = document.getElementById('dev-console');
const devInput = document.getElementById('dev-input');


window.addEventListener('keydown', (e) => {
  if (!devMode) return;
  
  if (e.key === '-') {
    e.preventDefault();
    const isHidden = devConsole.style.display === 'none';
    devConsole.style.display = isHidden ? 'block' : 'none';
    if (isHidden) devInput.focus();
  }
});


devInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    const raw = devInput.value.trim();
    if (raw) executeDevCommand(raw);
    devInput.value = "";
    devConsole.style.display = 'none';
  }
});

function executeDevCommand(input) {
  const parts = input.replace(/[(),]/g, ' ').split(/\s+/);
  const cmd = parts[0].toLowerCase();
  const args = parts.slice(1);

  switch (cmd) {
    case '/help':
      console.log("Commands: /warp [lvl] [x] [y], /give [item] [qty], /lvlup, /unlockall, /battle [enemyName], /god, /heal, /points");
      break;

    case '/warp':
      loadLevel(parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
      break;

    case '/give':
      const itemName = args[0];
      const qty = parseInt(args[1]) || 1;
      inventory.set(itemName, (inventory.get(itemName) || 0) + qty);
      showTemporaryText(`Gave ${qty} ${itemName}`);
      break;

    case '/lvlup':
      levelUp();
      break;

    case '/unlockall':
      alliesData.forEach(a => unlockedAllies.add(a.id));
      showTemporaryText("All allies unlocked!");
      drawPartyList();
      break;

    case '/battle':
      const enemyType = args[0];
      if (enemyTypes[enemyType]) {
        initiateBattle('interactable', { encounter: [{ type: enemyType }] });
      } else {
        showTemporaryText("Enemy type not found.");
      }
      break;

    case '/flag':
      const flagName = args[0];
    
      if (gameFlags.hasOwnProperty(flagName)) {
        gameFlags[flagName] = true;
        showTemporaryText(`Flag [${flagName}] is TRUE`);
        draw(); 
      } else {
        showTemporaryText(`Error: Flag '${flagName}' not found.`);
      }
      break;

    case '/god':
      playerStats.baseMaxHp = 9999;
      playerStats.maxHp = 9999;
      playerStats.currentHp = 9999;
      playerStats.damage = 999;
      updateHp(9999);
      updateStatsPopup();
      showTemporaryText("GOD MODE ACTIVE");
      break;

    case '/heal':
      playerStats.currentHp = playerStats.maxHp;
      updateHp(playerStats.currentHp);
      if (activeAlly) {
        activeAlly.currentHp = activeAlly.maxHp;
        drawPartyStatus();
      }
      showTemporaryText("Team Healed!");
      break;

    case '/points':
    showTemporaryText(`Good: ${goodPoints} | Bad: ${badPoints}`);
  break;

  case '/outlines':
      gameSettings.showZones = !gameSettings.showZones;
      showTemporaryText("Debug Outlines: " + (gameSettings.showZones ? "ON" : "OFF"));
      saveSettings();
      draw();
      break;

    case '/stamina':
      updateStamina(playerStats.maxStamina);
      showTemporaryText("Stamina Refilled!");
      break;

    default:
      showTemporaryText("Unknown command. Type /help");
  }
}


const gameHud = document.getElementById('game-hud');
if (gameHud) {
  const loadButton = document.createElement('button');
  loadButton.textContent = 'Load Autosave';
  loadButton.style.fontFamily = "'Press Start 2P', sans-serif";
  loadButton.style.margin = '0 10px';
  loadButton.onclick = loadGame;
  gameHud.appendChild(loadButton);
}
  

canvas.addEventListener('keydown', function(e) {
  const isDialogActive = document.getElementById('dialog-overlay').style.display === 'flex';
if (inBattle || isGameOver || isDialogActive || document.getElementById('fade-overlay').style.opacity > 0) {
      return;
  }

 
  if (sliding) return;

  let nextX = x, nextY = y;
  const key = e.key.toLowerCase();


  if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(key)) {
    e.preventDefault();
  }


  if (key === 'x') {
    e.preventDefault();
    const interactableObject =
      checkInteraction(x - 16, y) ||
      checkInteraction(x + 16, y) ||
      checkInteraction(x, y - 16) ||
      checkInteraction(x, y + 16) ||
      checkInteraction(x, y);
    if (interactableObject) handleInteraction(interactableObject);
    return;
  }

 
  let dirX = 0, dirY = 0;

if (key === 'arrowleft' || key === 'a') {
  dirX = -1;
  currentFacing = 'left';
}
if (key === 'arrowright' || key === 'd') {
  dirX = 1;
  currentFacing = 'right';
}
if (key === 'arrowup' || key === 'w') {
  dirY = -1;
  currentFacing = 'up';
}
if (key === 'arrowdown' || key === 's') {
  dirY = 1;
  currentFacing = 'down';
}

  
  if (dirX === 0 && dirY === 0) return;

 
  nextX = x + dirX * speed;
  nextY = y + dirY * speed;


  if (isInWater(nextX, nextY) && (inventory.get('raft') || 0) <= 0) {
    showTemporaryText("You need a raft to cross water!");
    return;
  }


  if (isInPoison(nextX, nextY) && (inventory.get('gas_mask') || 0) <= 0) {
    showTemporaryText("You need a gas mask to cross poison!");
    return;
  }

  if (!isCollidingWithWall(nextX, nextY)) {
    const door = checkDoorCollision(nextX, nextY);
if (door) {

  loadLevel(door.destLevel, door.destX, door.destY);
  
  if (door.dialog) {
    setTimeout(() => {
      showDialog(door.dialog, null, { 
        speaker: door.speaker || null, 
        style: door.style || 'dialog' 
      });
    }, 750);
  }
  return;
}

    const battleZone = findBattleZone(nextX, nextY);
    if (battleZone) {
      initiateBattle('battleZone', battleZone);
      return;
    }

   
    const startedSlide = tryEnterSlideIfNeeded(x, y, nextX, nextY, dirX, dirY);

    
    x = nextX;
    y = nextY;

    if (startedSlide) {
    
      if (typeof updateHp === 'function') updateHp(playerStats.currentHp);
      draw();
      return;
    }


    const dialogZone = findDialogZone(nextX, nextY);
    if (dialogZone && dialogZone.autoShow) {
      showDialog(dialogZone.text, dialogZone.id, { style: dialogZone.style || 'dialog', speaker: dialogZone.speaker || null });
      return;
    }
  }

  draw();
});
  </script>
</body>
</html>
